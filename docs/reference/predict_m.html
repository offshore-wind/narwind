<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>predict_backup &lt;- function(obj,
         yrs = 35,
         n = 100,
         popr = 1,
         do.plot = FALSE,
         seed = 125897,
         ...) 
  
  set.seed(seed)
  
  if(sum(suppressWarnings(purrr::map_lgl(.x = obj$gam$pred, .f = ~any(is.na(.x)))) &gt; 0)) 
    stop("Insufficient sample size. Cannot make predictions.") 
  
  # Function ellipsis –– optional arguments
  args &lt;- list(...)
  
  # Default values
  if(length(args) == 0)
    spline &lt;- TRUE
    progress &lt;- TRUE
   else 
    if("spline" 
    if("progress" 
  
  
  cat("Initializing ...")
  
  # if(is.null(obj$gam)) stop("Insufficient data available. Cannot proceed with population projections.")
  # if(!identical(cohortID, 1:6)) stop("Missing cohorts in input &lt;obj&gt;. Cannot proceed with population projections.")
  # if(length(obj$gam$fit$surv$xlevels[[1]]) &lt; 6 | length(obj$gam$fit$bc$xlevels[[1]]) &lt; 6) stop("Missing factor levels in input &lt;obj&gt;. Cannot proceed with population projections.")
  
  # plogis("link" predictions + error)
  
  # Adapted from original code by Scott Creel
  # https://www.montana.edu/screel/teaching/bioe-440r-521/course-outline/stoch_projection_new.R
  # 
  # Prediction intervals
  # https://stat.ethz.ch/pipermail/r-help/2011-April/275632.html
  
  # Population estimate as per 2022 NARW report card is 340 (+/- 7).
  
  # test &lt;- mgcv::predict.gam(mod$gam[[1]]$surv, newdata = data.frame(start_bc = seq(0, find_maxBC(), 0.01)), type = "link", se.fit = TRUE)
  # plot(seq(0,find_maxBC(), 0.01), plogis(test$fit), type = "l")
  # lines(seq(0, find_maxBC(), 0.01), plogis(Reduce("+", test)), lty = 2)
  # lines(seq(0, find_maxBC(), 0.01), plogis(Reduce("-", test)), lty = 2)
  # test2 &lt;- mgcv::predict.gam(mod$gam[[1]]$surv, newdata = data.frame(start_bc = 0.2), type = "response")
  # abline(v = 0.2)
  # abline(h = tesct2)
  
  cohortID &lt;- obj$param$cohortID
  cohorts &lt;- obj$param$cohorts |&gt; dplyr::slice(1) |&gt; 
    dplyr::mutate(name = gsub(", female", "", name), abb = gsub(",f", "", abb)) |&gt; 
    dplyr::bind_rows(obj$param$cohorts) |&gt; 
    dplyr::mutate(name = gsub("male, female", "female", name), abb = gsub("m,f", "f", abb))
  cohorts &lt;- cohorts[c(1,3,5,2,4,6,7,8)]
  
  # Attributes to monitor during projection
  mat.attribs &lt;- c("alive", "cohort", "female", "age", "length", "length_a", "length_b", "length_c",
                   "tot_mass", "lean_mass", "bc", "mass_a", "mass_b", "p_surv", "min_bc", "trest", "t2calf", "birth")
  
  # Current year
  current.yr &lt;- lubridate::year(lubridate::now())
  
  # Extract terminal functions
  mod &lt;- obj$gam$fit
  mod[["gest"]] &lt;- gam_gest
  
  #'------------------------------------------------------
  # GAM PARAMETERS
  #'------------------------------------------------------
  
  mbc_preds &lt;- obj$gam$pred$bc_gest
  bc_preds &lt;- obj$gam$pred$bc
  surv_preds &lt;- obj$gam$pred$surv
  
  #'------------------------------------------------------
  # INITIALIZATION
  #'------------------------------------------------------
  
  # Define initial population vector
  # c(F1 = 0, F2 = 0, F3 = 2, F4 = 6, F5 = 4, F6 = 0, F7 = 6, F8 = 0, 
  # F9 = 5, "F10+" = 48, FC = 7, FR = 0, FB = 61, 
  # M1 = 0, M2 = 0, 
  # M3 = 2, M4 = 5, 
  # "M5+" = 212)
  N0 &lt;- c(0, 7, 212, 0, 71, 1, 7, 61)
  names(N0) &lt;- cohorts[, name]
  totn &lt;- sum(N0)* (1 + popr)
  
  cat("Setting up ...")
  
  # Create matrices and initialize them
  # rows: years &lt;yrs&gt;
  # columns: &lt;attributes&gt;
  # layers: individuals &lt;n&gt;
  # 4th dimension: replicate projection -&gt; later converted to list
  narw.indiv &lt;- array(data = NA, c(yrs + 1, length(mat.attribs), totn, n), 
                      dimnames = list(paste0("yr ", 0:yrs), 
                                      mat.attribs,
                                      paste0("whale ", 1:totn),
                                      paste0("prj ", 1:n)))
  
  cohort.vec &lt;- do.call(c, sapply(X = 1:nrow(cohorts), FUN = function(x) rep(cohorts$id[x], each = N0[x])))
  
  animals &lt;- 1:sum(N0)
  
  # Alive and population cohort
  narw.indiv[1, "alive", animals, ] &lt;- rep(1, )
  narw.indiv[1, "cohort", animals, ] &lt;- rep(cohort.vec, n)
  
  # Sex
  #  -- Calves (male)
  narw.indiv[, "female", 1:N0[1], ] &lt;- 0
  #  -- Calves (female)
  fem &lt;- which(cohort.vec == 0)
  narw.indiv[, "female", fem[fem &gt; N0[1]], ] &lt;- 1
  #  -- Juveniles and adults
  narw.indiv[, "female", which(cohort.vec 
  narw.indiv[, "female", which(cohort.vec 
  
  cat("Age ...")
  
  # Age
  ages &lt;- start_age_vec(rep(cohort.vec, n))
  narw.indiv[1, "age", animals, ] &lt;- ages
  
  cat("Length ...")
  
  # Total body length
  l.params &lt;- agL_vec(ages)
  lengths &lt;- age2length_vec(ages, l.params)
  narw.indiv[1, "length", animals, ] &lt;- lengths
  
  narw.indiv[, "length_a", animals, ] &lt;- rep(l.params[, 1], each = yrs + 1)
  narw.indiv[, "length_b", animals, ] &lt;- rep(l.params[, 2], each = yrs + 1)
  narw.indiv[, "length_c", animals, ] &lt;- rep(l.params[, 3], each = yrs + 1)
  
  cat("Mass ...")
  
  # Lean mass
  m.params &lt;- mL(n * sum(N0))
  narw.indiv[, "mass_a", animals, ] &lt;- rep(m.params[, 1], each = yrs + 1)
  narw.indiv[, "mass_b", animals, ] &lt;- rep(m.params[, 2], each = yrs + 1)
  mass &lt;- length2mass_vec(lengths, m.params)
  narw.indiv[1, "lean_mass", animals, ] &lt;- mass
  
  # Body conditon
  bc &lt;- start_bcondition_vec(rep(cohort.vec, n))
  narw.indiv[1, "bc", animals, ] &lt;- bc
  
  # Total mass
  narw.indiv[1, "tot_mass", animals, ] &lt;- mass / (1-bc)
  
  # Calving interval - mean of 5.3 years, up to apparent gaps of 13 years (Kraus et al. 2001)
  # NARWC Report Card 2022: Average inter-birth interval of 7.7 yrs, median of 8, min/max (2/13)
  # This corresponds to a Normal (7.7, 1.45)
  # Mean age at first calving = 9.53 +/- 2.32 (Kraus et al. 2001)
  # 
  # Stewart et al. 2022 -- 
  # The degree to which the energetic reserves of females are depleted during lactation may govern
  # the length of the resting period between successful pregnancies (Miller et al. 2011, Marón et al. 2015).
  
  cat("Reproduction ...")
  
  t2calf &lt;- (rep(cohort.vec, n) == 6) * random_int(sum(N0) * n)
  narw.indiv[1, "t2calf", animals, ] &lt;- t2calf
  narw.indiv[1, "trest", animals, ] &lt;- as.numeric(ifelse(t2calf == 0, 13, 1)) * (as.numeric(narw.indiv[1, "cohort", animals, ]) == 6)
  
  if (!spline) 
    narw.indiv[1, "min_bc", animals, ] &lt;- predict_m(
      model = mod,
      values = as.vector(narw.indiv[1, "tot_mass", animals, ]),
      prediction = "gest"
    ) * as.vector(narw.indiv[1, "cohort", animals, ] == 6)
   else 
    narw.indiv[1, "min_bc", animals, ] &lt;- mbc_preds(narw.indiv[1, "tot_mass", animals, ]) * (narw.indiv[1, "cohort", animals, ] == 6)
  
  
  narw.indiv[1, "birth", animals, ] &lt;- ifelse(narw.indiv[1, "trest", animals, ] == 13 &amp; narw.indiv[1, "t2calf", animals, ] == 0, 1, 0)
  narw.indiv[1, "p_surv", animals, ] &lt;- 1
  
  cat("List ...")
  
  #' ---------------------------
  # IMPORTANT 
  #' ---------------------------
  # Turn array into a list
  narw.indiv &lt;- purrr::array_branch(narw.indiv, 4) # bottleneck
  
  cat("totpop ...")
  
  # Number of individuals in each cohort
  narw.pop &lt;- array(
    data = NA, c(n, yrs + 1, nrow(cohorts)),
    dimnames = list(
      paste0("prj ", 1:n),
      paste0("yr ", 0:yrs),
      cohorts$name
    )
  )
  narw.pop[, 1, ] &lt;- rep(N0, each = n)
  
  cat("totpopinit ...")
  
  # Total population size
  tot.pop &lt;- matrix(0, n, yrs + 1, dimnames = list(paste0("prj", 1:n), paste0("yr ", 0:yrs)))
  tot.pop[, 1] &lt;- sum(N0)
  
  #'------------------------------------------------------
  # RUN PROJECTIONS
  #'------------------------------------------------------
  
  # This uses nested loops. 
  # The prj loop (outermost loop) replicates the projection &lt;n&gt; times.
  # The i loop is next, and steps across all years of projection from an initial population vector.
  
  # Set up progress bar
  pb &lt;- progress::progress_bar$new(
    format = "[:bar] :percent eta: :eta",
    total = n, clear = FALSE, width = 80
  )
  
  cat("Running projections ...")
  start.time &lt;- Sys.time()
  
  for(prj in 1:n)
    
    if(progress) pb$tick() # Update progress bar
    
    animals &lt;- 1:sum(N0)
    
    #'------------------------------------------------------
    # Loop over years
    #'------------------------------------------------------
    
    for(i in 2:(yrs+1))
      
      current.dat &lt;- as.matrix(narw.indiv[[prj]][i-1, , animals])
      alive &lt;- current.dat["alive", animals] * (current.dat["age", animals] &lt;=69)
      
      #' ----------------------------
      # SURVIVAL
      #' ----------------------------
      # Predict survival probability based on body condition
      
      if(!spline)
        
        ps &lt;- alive * predict_m(model = mod, cohort = current.dat["cohort",animals], 
                                values = current.dat["bc",animals], prediction = "surv")
        
       else 
        
        ps &lt;- alive * (surv_preds[["0"]](current.dat["bc",animals]) * (current.dat["cohort",animals] == 0) +
                         surv_preds[["1"]](current.dat["bc",animals]) * (current.dat["cohort",animals] == 1) +
                         surv_preds[["2"]](current.dat["bc",animals]) * (current.dat["cohort",animals] == 2) +
                         surv_preds[["3"]](current.dat["bc",animals]) * (current.dat["cohort",animals] == 3) +
                         surv_preds[["4"]](current.dat["bc",animals]) * (current.dat["cohort",animals] == 4) +
                         surv_preds[["5"]](current.dat["bc",animals]) * (current.dat["cohort",animals] == 5) +
                         surv_preds[["6"]](current.dat["bc",animals]) * (current.dat["cohort",animals] == 6))
      
      
      # ps &lt;- 1
      narw.indiv[[prj]][i, "p_surv", animals] &lt;- ps
      
      # Determine whether the animal survived
      alive &lt;- rbinom(n = animals, size = 1, prob = ps) * (current.dat["age", animals] &lt;=69)
      narw.indiv[[prj]][i, "alive", animals] &lt;- alive
      
      # Sex remains the same
      narw.indiv[[prj]][i, "female", animals] &lt;- current.dat["female", animals]
      
      #' ----------------------------
      # GROWTH
      #' ----------------------------
      
      # Increment age
      narw.indiv[[prj]][i, "age", animals] &lt;- alive * (current.dat["age", animals] + 1)
      
      # Increment length
      newLp &lt;- agL_vec(animals)
      
      narw.indiv[[prj]][i,"length_a", animals] &lt;- 
        ifelse(narw.indiv[[prj]][i, "age", animals] == 1, newLp[,1], current.dat["length_a", animals])
      
      narw.indiv[[prj]][i,"length_b", animals] &lt;- 
        ifelse(narw.indiv[[prj]][i, "age", animals] == 1, newLp[,2], current.dat["length_b", animals])
      
      narw.indiv[[prj]][i,"length_c", animals] &lt;- 
        ifelse(narw.indiv[[prj]][i, "age", animals] == 1, newLp[,3], current.dat["length_c", animals])
      
      narw.indiv[[prj]][i, "length", animals] &lt;-
        alive * age2length_vec(
          narw.indiv[[prj]][i, "age", animals],
          t(narw.indiv[[prj]][i, c("length_a", "length_b", "length_c"), animals])
        )
      
      # Increment lean mass
      narw.indiv[[prj]][i, "lean_mass", animals] &lt;- alive * length2mass_vec(narw.indiv[[prj]][i, "length", animals],
                                                                            t(narw.indiv[[prj]][i, c("mass_a", "mass_b"), animals]), lean = TRUE)
      
      # Predict new body condition from current body condition
      if (!spline) 
        narw.indiv[[prj]][i, "bc", animals] &lt;- alive * predict_m(
          model = mod, cohort = current.dat["cohort", animals],
          values = current.dat["bc", animals], prediction = "bc")
       else 
        narw.indiv[[prj]][i, "bc", animals] &lt;-
          alive * (bc_preds[["0"]](current.dat["bc", animals]) * (current.dat["cohort", animals] == 0) +
                     bc_preds[["1"]](current.dat["bc", animals]) * (current.dat["cohort", animals] == 1) +
                     bc_preds[["2"]](current.dat["bc", animals]) * (current.dat["cohort", animals] == 2) +
                     bc_preds[["3"]](current.dat["bc", animals]) * (current.dat["cohort", animals] == 3) +
                     bc_preds[["4"]](current.dat["bc", animals]) * (current.dat["cohort", animals] == 4) +
                     bc_preds[["5"]](current.dat["bc", animals]) * (current.dat["cohort", animals] == 5) +
                     bc_preds[["6"]](current.dat["bc", animals]) * (current.dat["cohort", animals] == 6))
      
      
      # Increment total mass
      narw.indiv[[prj]][i, "tot_mass", animals] &lt;-
        alive * narw.indiv[[prj]][i, "lean_mass", animals] / (1 - narw.indiv[[prj]][i, "bc", animals])
      
      #' ----------------------------
      # REPRODUCTION
      #' ----------------------------
      
      # Which animals are resting females?
      rest.females &lt;- (current.dat["cohort", animals] == 6)
      
      # Which animals are juvenile females that are ready to start reproducing
      juvenile.females.ofage &lt;- (current.dat["cohort", animals] == 2) * (current.dat["age", animals] &gt;= 9)
      
      # Which animals calved in previous step?
      prev.births &lt;- current.dat["birth", animals]
      
      newt2calf &lt;- ifelse(prev.births == 1, random_int(sum(prev.births), lwr = 1), 
                          ifelse(current.dat["t2calf", animals] == 0, 0, 
                                 current.dat["t2calf", animals] - 1))
      
      # Time spent in resting state - only incremented if calving event hasn't occurred, otherwise reset
      narw.indiv[[prj]][i, "t2calf", animals] &lt;- alive * rest.females * newt2calf
      
      # Years until next calving event
      narw.indiv[[prj]][i, "trest", animals] &lt;- 
        alive * (rest.females | juvenile.females.ofage) * 
        ifelse(narw.indiv[[prj]][i - 1, "trest", animals] == 13, 1, current.dat["trest", animals] + 1)
      
      # Minimum body condition needed to successfully bring fetus to term without starving
      # No evidence of reproductive senescence in right whales - Hamilton et al. (1998)
      
      if (!spline) 
        narw.indiv[[prj]][i, "min_bc", animals] &lt;-
          alive * predict_m(model = mod, values = narw.indiv[[prj]][i, "tot_mass", animals], prediction = "gest") * rest.females
       else 
        narw.indiv[[prj]][i, "min_bc", animals] &lt;-
          alive * mbc_preds(narw.indiv[[prj]][i, "tot_mass", animals]) * rest.females
      
      
      # Birth of new calf, conditional on the mother being alive, in pregnant state
      narw.indiv[[prj]][i, "birth", animals] &lt;- alive * (current.dat["cohort", animals] == 4)
      
      # Maturity - transitions between cohorts
      narw.indiv[[prj]][i, "cohort", animals] &lt;-
        alive * increment_cohort(
          cohort = narw.indiv[[prj]][i - 1, "cohort", animals],
          age = narw.indiv[[prj]][i, "age", animals],
          female = narw.indiv[[prj]][i, "female", animals],
          bc = narw.indiv[[prj]][i, "bc", animals],
          min_bc = narw.indiv[[prj]][i, "min_bc", animals],
          trest = narw.indiv[[prj]][i, "trest", animals],
          t2calf = narw.indiv[[prj]][i, "t2calf", animals])
      
      new.births &lt;- sum(narw.indiv[[prj]][i, "birth", animals])
      
      if(new.births &gt; 0)
        narw.indiv[[prj]][i, , (max(animals)+1):(max(animals)+new.births)] &lt;- add_calf(n = new.births, attr = mat.attribs)
        animals &lt;- 1:(length(animals) + new.births)
      
      
      # Number of animals in each cohort
      # Calves (male)
      narw.pop[prj, i, 1] &lt;- sum((narw.indiv[[prj]][i, "cohort", animals] == 0) *
                                   (narw.indiv[[prj]][i, "female", animals] == 0) *
                                   (narw.indiv[[prj]][i, "alive", animals] == 1))
      
      # Juveniles and adults (male)
      narw.pop[prj, i, 2] &lt;- sum((narw.indiv[[prj]][i, "cohort", animals] == 1) * (narw.indiv[[prj]][i, "alive", animals] == 1))
      narw.pop[prj, i, 3] &lt;- sum((narw.indiv[[prj]][i, "cohort", animals] == 3) * (narw.indiv[[prj]][i, "alive", animals] == 1))
      
      # Calves (female)
      narw.pop[prj, i, 4] &lt;- sum((narw.indiv[[prj]][i, "cohort", animals] == 0) *
                                   (narw.indiv[[prj]][i, "female", animals] == 1) *
                                   (narw.indiv[[prj]][i, "alive", animals] == 1))
      
      # Juvenile and reproductive adults (female)
      narw.pop[prj, i, 5] &lt;- sum((narw.indiv[[prj]][i, "cohort", animals] == 2) * (narw.indiv[[prj]][i, "alive", animals] == 1))
      narw.pop[prj, i, 6] &lt;- sum((narw.indiv[[prj]][i, "cohort", animals] == 4) * (narw.indiv[[prj]][i, "alive", animals] == 1))
      narw.pop[prj, i, 7] &lt;- sum((narw.indiv[[prj]][i, "cohort", animals] == 5) * (narw.indiv[[prj]][i, "alive", animals] == 1))
      narw.pop[prj, i, 8] &lt;- sum((narw.indiv[[prj]][i, "cohort", animals] == 6) * (narw.indiv[[prj]][i, "alive", animals] == 1))
      
      # Total population size
      tot.pop[prj, i] &lt;- sum(narw.indiv[[prj]][i, "alive", animals], na.rm = TRUE)
      
     # End years
   # End projections
  
  end.time &lt;- Sys.time()
  run_time &lt;- hms::round_hms(hms::as_hms(difftime(time1 = end.time, time2 = start.time, units = "auto")), 1)
  
  cat("Processing outputs ...")
  
  # narw.out &lt;- purrr::map(.x = 1:n, .f = ~
  #   reshape_array(narw.indiv[[.x]], value, yr, attr, whale) |&gt; 
  #     dplyr::mutate(attr = mat.attribs[attr]) |&gt; 
  #     tidyr::pivot_wider(names_from = attr, values_from = value) |&gt; 
  #     dplyr::mutate(prj = .x) |&gt; 
  #     dplyr::relocate(prj, .before = yr)
  # ) |&gt; do.call(what = rbind) |&gt; 
  #   data.table::data.table()
  
  # narw.out &lt;- narw.out[is.finite(rowSums(narw.out)),]
  
  narw.df &lt;- purrr::map(.x = cohorts$name, .f = ~
    narw.pop[,,.x] |&gt; 
      tibble::as_tibble() |&gt; 
      tibble::rownames_to_column(var = "prj") |&gt; 
      tidyr::pivot_longer(!prj, names_to = "year", values_to = "N") |&gt; 
      dplyr::mutate(year = current.yr + as.numeric(gsub("yr ", "", year))) |&gt; 
      dplyr::mutate(cohort = stringr::str_to_sentence(.x))
  ) |&gt; do.call(what = rbind) |&gt; data.table::data.table()
  
  tot.df &lt;- tibble::as_tibble(tot.pop) |&gt; 
    tibble::rownames_to_column(var = "prj") |&gt; 
    tidyr::pivot_longer(!prj, names_to = "year", values_to = "N") |&gt; 
    dplyr::mutate(year = current.yr + as.numeric(gsub("yr ", "", year))) |&gt; 
    dplyr::mutate(cohort = "North Atlantic right whales") |&gt; data.table::data.table()
  
  # births.df &lt;- purrr::map(.x = 1:n, .f = ~
  #   m &lt;- matrix(rowSums(narw.indiv[[.x]][2:(yrs+1),"birth",], na.rm = TRUE), ncol = 1)
  #   colnames(m) &lt;- .x
  #   m
  # ) |&gt; do.call(what = cbind) |&gt; 
  #   tibble::as_tibble() |&gt; 
  #   tibble::rownames_to_column(var = "year") |&gt; 
  #   dplyr::mutate(year = as.numeric(year)) |&gt; 
  #   tidyr::pivot_longer(!year, names_to = "prj", values_to = "birth") |&gt; 
  #   dplyr::select(prj, year, birth) |&gt; 
  #   dplyr::arrange(prj, year) |&gt; 
  #   data.table::data.table()
  # 
  # deaths.df &lt;- purrr::map(.x = 1:n, .f = ~
  #   m &lt;- matrix(apply(X = narw.indiv[[.x]][2:(yrs+1),"alive",],
  #                     MARGIN = 1,
  #                     FUN = function(x) 
  #     r &lt;- x[!is.na(x)]
  #     r &lt;- sum(r == 0)
  #     r
  #     ), ncol = 1)
  #   colnames(m) &lt;- .x
  #   m
  # ) |&gt; do.call(what = cbind) |&gt;
  #   tibble::as_tibble() |&gt;
  #   tibble::rownames_to_column(var = "year") |&gt;
  #   dplyr::mutate(year = as.numeric(year)) |&gt;
  #   tidyr::pivot_longer(!year, names_to = "prj", values_to = "death") |&gt;
  #   dplyr::select(prj, year, death) |&gt;
  #   dplyr::arrange(prj, year) |&gt;
  #   data.table::data.table()
  
  narw.conf &lt;- narw.df[
    , list(
      mean = mean(N),
      lwr = quantile(N, 0.025, na.rm = TRUE),
      uppr = quantile(N, 0.975, na.rm = TRUE)
    ),
    list(year, cohort)
  ] |&gt;
    dplyr::mutate(cohort = factor(cohort, levels = c(
      "Calves (male)",
      "Calves (female)",
      "Juveniles (male)",
      "Juveniles (female)",
      "Adults (male)",
      "Adults (female, pregnant)",
      "Adults (female, lactating)",
      "Adults (female, resting)"
    )))
  
  tot.conf &lt;- tot.df[
    , list(
      mean = mean(N),
      lwr = quantile(N, 0.025),
      uppr = quantile(N, 0.975)
    ),
    list(year, cohort)
  ] |&gt;
    dplyr::mutate(cohort = factor(cohort, levels = c(
      "Calves (male)",
      "Calves (female)",
      "Juveniles (male)",
      "Juveniles (female)",
      "Adults (male)",
      "Adults (female, pregnant)",
      "Adults (female, lactating)",
      "Adults (female, resting)",
      "North Atlantic right whales"
    )))
  
  p1 &lt;- plot_projection(narw.df, narw.conf)
  p2 &lt;- plot_projection(tot.df, tot.conf)
  
  if(do.plot)
    print(p1)
    print(p2)
  
  
  # Find 95
  cat("Final population size:")
  final.pop &lt;- unname(tot.df[year == current.yr + yrs,  quantile(N, probs = c(0.5, 0.025, 0.975))])
  cat("N = ", round(final.pop[1],0), " (95
  
  cat(paste0("Time elapsed: ", run_time))
  cat("")
  
  return(list(
    # dat = narw.out,
    out = list(df = rbind(narw.df, tot.df), 
               ci = rbind(narw.conf, tot.conf),
               plot = list(p1, p2)))) — predict_m • narwind</title><!-- jquery --><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script><!-- Bootstrap --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous"><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script><!-- bootstrap-toc --><link rel="stylesheet" href="../bootstrap-toc.css"><script src="../bootstrap-toc.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous"><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet"><script src="../pkgdown.js"></script><link href="../extra.css" rel="stylesheet"><meta property="og:title" content="predict_backup &lt;- function(obj,
         yrs = 35,
         n = 100,
         popr = 1,
         do.plot = FALSE,
         seed = 125897,
         ...) 
  
  set.seed(seed)
  
  if(sum(suppressWarnings(purrr::map_lgl(.x = obj$gam$pred, .f = ~any(is.na(.x)))) &gt; 0)) 
    stop(" insufficient sample size. cannot make predictions. function ellipsis optional arguments args list default values if spline true progress else cat ... stop data available. proceed with population projections. cohorts in input length factor levels plogis predictions error adapted from original code by scott creel https: prediction intervals estimate as per narw report card is test mgcv::predict.gam newdata="data.frame(start_bc" seq find_maxbc type="link" se.fit="TRUE)" plot lines lty="2)" test2 abline tesct2 cohortid obj dplyr::slice dplyr::mutate gsub female name abb='gsub(",f",' dplyr::bind_rows attributes to monitor during projection mat.attribs c current year current.yr lubridate::year extract terminal functions mod gam_gest gam parameters mbc_preds bc_preds surv_preds initialization define initial vector f2="0," f3="2," f4="6," f5="4," f6="0," f7="6," f8="0," f9="5," fc="7," fr="0," fb="61," m1="0," m2="0," m3="2," m4="5," n0 names totn sum popr up create matrices and initialize them rows: years columns: layers: individuals dimension: replicate later converted narw.indiv array na n dimnames='list(paste0("yr' paste0 cohort.vec do.call sapply fun="function(x)" rep each="N0[x])))" animals alive cohort sex calves fem which juveniles adults age ages start_age_vec total body l.params agl_vec lengths age2length_vec lean mass m.params ml length2mass_vec conditon bc start_bcondition_vec calving interval mean of apparent gaps et al. narwc average inter-birth yrs median min this corresponds a normal at first stewart the degree energetic reserves females are depleted lactation may govern resting period between successful pregnancies mar t2calf random_int as.numeric predict_m model="mod," as.vector ifelse important turn into purrr::array_branch bottleneck number narw.pop nrow size tot.pop matrix run projections uses nested loops. prj loop replicates times. i next steps across all an vector. set bar pb progress::progress_bar format="[:bar] :percent eta: :eta" clear="FALSE," width="80" start.time sys.time for update over current.dat as.matrix survival predict probability based on condition ps determine whether animal survived rbinom prob="ps)" remains same growth increment newlp t new reproduction rest.females juvenile that ready start reproducing juvenile.females.ofage calved previous step prev.births newt2calf lwr="1)," time spent state only incremented event hasn occurred otherwise reset until minimum needed successfully bring fetus term without starving no evidence reproductive senescence right whales hamilton birth calf conditional mother being pregnant maturity transitions increment_cohort min_bc="narw.indiv[[prj]][i," trest="narw.indiv[[prj]][i," new.births add_calf attr="mat.attribs)" na.rm="TRUE)" end end.time run_time hms::round_hms time2="start.time," units="auto" outputs narw.out purrr::map .f="~" reshape_array value yr whale tidyr::pivot_wider values_from="value)" .x dplyr::relocate .before="yr)" rbind data.table::data.table narw.df tibble::as_tibble tibble::rownames_to_column tidyr::pivot_longer names_to="year" values_to="N" stringr::str_to_sentence tot.df atlantic births.df m ncol="1)" colnames cbind dplyr::select dplyr::arrange deaths.df margin="1," r x death narw.conf uppr="quantile(N," lactating tot.conf p1 plot_projection p2 print find size: final.pop unname quantile probs="c(0.5," round elapsed: return dat="narw.out," out="list(df" ci="rbind(narw.conf,"><meta property="og:description" content="predict_backup &amp;lt;- function(obj,
         yrs = 35,
         n = 100,
         popr = 1,
         do.plot = FALSE,
         seed = 125897,
         ...)   set.seed(seed)  if(sum(suppressWarnings(purrr::map_lgl(.x = obj$gam$pred, .f = ~any(is.na(.x)))) &amp;gt; 0)) 
    stop(&quot;Insufficient sample size. Cannot make predictions.&quot;)   # Function ellipsis –– optional arguments
  args &amp;lt;- list(...)  # Default values
  if(length(args) == 0)
    spline &amp;lt;- TRUE
    progress &amp;lt;- TRUE
   else 
    if(&quot;spline&quot; 
    if(&quot;progress&quot;   cat(&quot;Initializing ...&quot;)  # if(is.null(obj$gam)) stop(&quot;Insufficient data available. Cannot proceed with population projections.&quot;)
  # if(!identical(cohortID, 1:6)) stop(&quot;Missing cohorts in input &amp;lt;obj&amp;gt;. Cannot proceed with population projections.&quot;)
  # if(length(obj$gam$fit$surv$xlevels[[1]]) &amp;lt; 6 | length(obj$gam$fit$bc$xlevels[[1]]) &amp;lt; 6) stop(&quot;Missing factor levels in input &amp;lt;obj&amp;gt;. Cannot proceed with population projections.&quot;)  # plogis(&quot;link&quot; predictions + error)  # Adapted from original code by Scott Creel
  # https://www.montana.edu/screel/teaching/bioe-440r-521/course-outline/stoch_projection_new.R
  # 
  # Prediction intervals
  # https://stat.ethz.ch/pipermail/r-help/2011-April/275632.html  # Population estimate as per 2022 NARW report card is 340 (+/- 7).  # test &amp;lt;- mgcv::predict.gam(mod$gam[[1]]$surv, newdata = data.frame(start_bc = seq(0, find_maxBC(), 0.01)), type = &quot;link&quot;, se.fit = TRUE)
  # plot(seq(0,find_maxBC(), 0.01), plogis(test$fit), type = &quot;l&quot;)
  # lines(seq(0, find_maxBC(), 0.01), plogis(Reduce(&quot;+&quot;, test)), lty = 2)
  # lines(seq(0, find_maxBC(), 0.01), plogis(Reduce(&quot;-&quot;, test)), lty = 2)
  # test2 &amp;lt;- mgcv::predict.gam(mod$gam[[1]]$surv, newdata = data.frame(start_bc = 0.2), type = &quot;response&quot;)
  # abline(v = 0.2)
  # abline(h = tesct2)  cohortID &amp;lt;- obj$param$cohortID
  cohorts &amp;lt;- obj$param$cohorts |&amp;gt; dplyr::slice(1) |&amp;gt; 
    dplyr::mutate(name = gsub(&quot;, female&quot;, &quot;&quot;, name), abb = gsub(&quot;,f&quot;, &quot;&quot;, abb)) |&amp;gt; 
    dplyr::bind_rows(obj$param$cohorts) |&amp;gt; 
    dplyr::mutate(name = gsub(&quot;male, female&quot;, &quot;female&quot;, name), abb = gsub(&quot;m,f&quot;, &quot;f&quot;, abb))
  cohorts &amp;lt;- cohorts[c(1,3,5,2,4,6,7,8)]  # Attributes to monitor during projection
  mat.attribs &amp;lt;- c(&quot;alive&quot;, &quot;cohort&quot;, &quot;female&quot;, &quot;age&quot;, &quot;length&quot;, &quot;length_a&quot;, &quot;length_b&quot;, &quot;length_c&quot;,
                   &quot;tot_mass&quot;, &quot;lean_mass&quot;, &quot;bc&quot;, &quot;mass_a&quot;, &quot;mass_b&quot;, &quot;p_surv&quot;, &quot;min_bc&quot;, &quot;trest&quot;, &quot;t2calf&quot;, &quot;birth&quot;)  # Current year
  current.yr &amp;lt;- lubridate::year(lubridate::now())  # Extract terminal functions
  mod &amp;lt;- obj$gam$fit
  mod[[&quot;gest&quot;]] &amp;lt;- gam_gest  #'------------------------------------------------------
  # GAM PARAMETERS
  #'------------------------------------------------------  mbc_preds &amp;lt;- obj$gam$pred$bc_gest
  bc_preds &amp;lt;- obj$gam$pred$bc
  surv_preds &amp;lt;- obj$gam$pred$surv  #'------------------------------------------------------
  # INITIALIZATION
  #'------------------------------------------------------  # Define initial population vector
  # c(F1 = 0, F2 = 0, F3 = 2, F4 = 6, F5 = 4, F6 = 0, F7 = 6, F8 = 0, 
  # F9 = 5, &quot;F10+&quot; = 48, FC = 7, FR = 0, FB = 61, 
  # M1 = 0, M2 = 0, 
  # M3 = 2, M4 = 5, 
  # &quot;M5+&quot; = 212)
  N0 &amp;lt;- c(0, 7, 212, 0, 71, 1, 7, 61)
  names(N0) &amp;lt;- cohorts[, name]
  totn &amp;lt;- sum(N0)* (1 + popr)  cat(&quot;Setting up ...&quot;)  # Create matrices and initialize them
  # rows: years &amp;lt;yrs&amp;gt;
  # columns: &amp;lt;attributes&amp;gt;
  # layers: individuals &amp;lt;n&amp;gt;
  # 4th dimension: replicate projection -&amp;gt; later converted to list
  narw.indiv &amp;lt;- array(data = NA, c(yrs + 1, length(mat.attribs), totn, n), 
                      dimnames = list(paste0(&quot;yr &quot;, 0:yrs), 
                                      mat.attribs,
                                      paste0(&quot;whale &quot;, 1:totn),
                                      paste0(&quot;prj &quot;, 1:n)))  cohort.vec &amp;lt;- do.call(c, sapply(X = 1:nrow(cohorts), FUN = function(x) rep(cohorts$id[x], each = N0[x])))  animals &amp;lt;- 1:sum(N0)  # Alive and population cohort
  narw.indiv[1, &quot;alive&quot;, animals, ] &amp;lt;- rep(1, )
  narw.indiv[1, &quot;cohort&quot;, animals, ] &amp;lt;- rep(cohort.vec, n)  # Sex
  #  -- Calves (male)
  narw.indiv[, &quot;female&quot;, 1:N0[1], ] &amp;lt;- 0
  #  -- Calves (female)
  fem &amp;lt;- which(cohort.vec == 0)
  narw.indiv[, &quot;female&quot;, fem[fem &amp;gt; N0[1]], ] &amp;lt;- 1
  #  -- Juveniles and adults
  narw.indiv[, &quot;female&quot;, which(cohort.vec 
  narw.indiv[, &quot;female&quot;, which(cohort.vec   cat(&quot;Age ...&quot;)  # Age
  ages &amp;lt;- start_age_vec(rep(cohort.vec, n))
  narw.indiv[1, &quot;age&quot;, animals, ] &amp;lt;- ages  cat(&quot;Length ...&quot;)  # Total body length
  l.params &amp;lt;- agL_vec(ages)
  lengths &amp;lt;- age2length_vec(ages, l.params)
  narw.indiv[1, &quot;length&quot;, animals, ] &amp;lt;- lengths  narw.indiv[, &quot;length_a&quot;, animals, ] &amp;lt;- rep(l.params[, 1], each = yrs + 1)
  narw.indiv[, &quot;length_b&quot;, animals, ] &amp;lt;- rep(l.params[, 2], each = yrs + 1)
  narw.indiv[, &quot;length_c&quot;, animals, ] &amp;lt;- rep(l.params[, 3], each = yrs + 1)  cat(&quot;Mass ...&quot;)  # Lean mass
  m.params &amp;lt;- mL(n * sum(N0))
  narw.indiv[, &quot;mass_a&quot;, animals, ] &amp;lt;- rep(m.params[, 1], each = yrs + 1)
  narw.indiv[, &quot;mass_b&quot;, animals, ] &amp;lt;- rep(m.params[, 2], each = yrs + 1)
  mass &amp;lt;- length2mass_vec(lengths, m.params)
  narw.indiv[1, &quot;lean_mass&quot;, animals, ] &amp;lt;- mass  # Body conditon
  bc &amp;lt;- start_bcondition_vec(rep(cohort.vec, n))
  narw.indiv[1, &quot;bc&quot;, animals, ] &amp;lt;- bc  # Total mass
  narw.indiv[1, &quot;tot_mass&quot;, animals, ] &amp;lt;- mass / (1-bc)  # Calving interval - mean of 5.3 years, up to apparent gaps of 13 years (Kraus et al. 2001)
  # NARWC Report Card 2022: Average inter-birth interval of 7.7 yrs, median of 8, min/max (2/13)
  # This corresponds to a Normal (7.7, 1.45)
  # Mean age at first calving = 9.53 +/- 2.32 (Kraus et al. 2001)
  # 
  # Stewart et al. 2022 -- 
  # The degree to which the energetic reserves of females are depleted during lactation may govern
  # the length of the resting period between successful pregnancies (Miller et al. 2011, Marón et al. 2015).  cat(&quot;Reproduction ...&quot;)  t2calf &amp;lt;- (rep(cohort.vec, n) == 6) * random_int(sum(N0) * n)
  narw.indiv[1, &quot;t2calf&quot;, animals, ] &amp;lt;- t2calf
  narw.indiv[1, &quot;trest&quot;, animals, ] &amp;lt;- as.numeric(ifelse(t2calf == 0, 13, 1)) * (as.numeric(narw.indiv[1, &quot;cohort&quot;, animals, ]) == 6)  if (!spline) 
    narw.indiv[1, &quot;min_bc&quot;, animals, ] &amp;lt;- predict_m(
      model = mod,
      values = as.vector(narw.indiv[1, &quot;tot_mass&quot;, animals, ]),
      prediction = &quot;gest&quot;
    ) * as.vector(narw.indiv[1, &quot;cohort&quot;, animals, ] == 6)
   else 
    narw.indiv[1, &quot;min_bc&quot;, animals, ] &amp;lt;- mbc_preds(narw.indiv[1, &quot;tot_mass&quot;, animals, ]) * (narw.indiv[1, &quot;cohort&quot;, animals, ] == 6)  narw.indiv[1, &quot;birth&quot;, animals, ] &amp;lt;- ifelse(narw.indiv[1, &quot;trest&quot;, animals, ] == 13 &amp;amp; narw.indiv[1, &quot;t2calf&quot;, animals, ] == 0, 1, 0)
  narw.indiv[1, &quot;p_surv&quot;, animals, ] &amp;lt;- 1  cat(&quot;List ...&quot;)  #' ---------------------------
  # IMPORTANT 
  #' ---------------------------
  # Turn array into a list
  narw.indiv &amp;lt;- purrr::array_branch(narw.indiv, 4) # bottleneck  cat(&quot;totpop ...&quot;)  # Number of individuals in each cohort
  narw.pop &amp;lt;- array(
    data = NA, c(n, yrs + 1, nrow(cohorts)),
    dimnames = list(
      paste0(&quot;prj &quot;, 1:n),
      paste0(&quot;yr &quot;, 0:yrs),
      cohorts$name
    )
  )
  narw.pop[, 1, ] &amp;lt;- rep(N0, each = n)  cat(&quot;totpopinit ...&quot;)  # Total population size
  tot.pop &amp;lt;- matrix(0, n, yrs + 1, dimnames = list(paste0(&quot;prj&quot;, 1:n), paste0(&quot;yr &quot;, 0:yrs)))
  tot.pop[, 1] &amp;lt;- sum(N0)  #'------------------------------------------------------
  # RUN PROJECTIONS
  #'------------------------------------------------------  # This uses nested loops. 
  # The prj loop (outermost loop) replicates the projection &amp;lt;n&amp;gt; times.
  # The i loop is next, and steps across all years of projection from an initial population vector.  # Set up progress bar
  pb &amp;lt;- progress::progress_bar$new(
    format = &quot;[:bar] :percent eta: :eta&quot;,
    total = n, clear = FALSE, width = 80
  )  cat(&quot;Running projections ...&quot;)
  start.time &amp;lt;- Sys.time()  for(prj in 1:n)    if(progress) pb$tick() # Update progress bar    animals &amp;lt;- 1:sum(N0)    #'------------------------------------------------------
    # Loop over years
    #'------------------------------------------------------    for(i in 2:(yrs+1))      current.dat &amp;lt;- as.matrix(narw.indiv[[prj]][i-1, , animals])
      alive &amp;lt;- current.dat[&quot;alive&quot;, animals] * (current.dat[&quot;age&quot;, animals] &amp;lt;=69)      #' ----------------------------
      # SURVIVAL
      #' ----------------------------
      # Predict survival probability based on body condition      if(!spline)        ps &amp;lt;- alive * predict_m(model = mod, cohort = current.dat[&quot;cohort&quot;,animals], 
                                values = current.dat[&quot;bc&quot;,animals], prediction = &quot;surv&quot;)       else         ps &amp;lt;- alive * (surv_preds[[&quot;0&quot;]](current.dat[&quot;bc&quot;,animals]) * (current.dat[&quot;cohort&quot;,animals] == 0) +
                         surv_preds[[&quot;1&quot;]](current.dat[&quot;bc&quot;,animals]) * (current.dat[&quot;cohort&quot;,animals] == 1) +
                         surv_preds[[&quot;2&quot;]](current.dat[&quot;bc&quot;,animals]) * (current.dat[&quot;cohort&quot;,animals] == 2) +
                         surv_preds[[&quot;3&quot;]](current.dat[&quot;bc&quot;,animals]) * (current.dat[&quot;cohort&quot;,animals] == 3) +
                         surv_preds[[&quot;4&quot;]](current.dat[&quot;bc&quot;,animals]) * (current.dat[&quot;cohort&quot;,animals] == 4) +
                         surv_preds[[&quot;5&quot;]](current.dat[&quot;bc&quot;,animals]) * (current.dat[&quot;cohort&quot;,animals] == 5) +
                         surv_preds[[&quot;6&quot;]](current.dat[&quot;bc&quot;,animals]) * (current.dat[&quot;cohort&quot;,animals] == 6))      # ps &amp;lt;- 1
      narw.indiv[[prj]][i, &quot;p_surv&quot;, animals] &amp;lt;- ps      # Determine whether the animal survived
      alive &amp;lt;- rbinom(n = animals, size = 1, prob = ps) * (current.dat[&quot;age&quot;, animals] &amp;lt;=69)
      narw.indiv[[prj]][i, &quot;alive&quot;, animals] &amp;lt;- alive      # Sex remains the same
      narw.indiv[[prj]][i, &quot;female&quot;, animals] &amp;lt;- current.dat[&quot;female&quot;, animals]      #' ----------------------------
      # GROWTH
      #' ----------------------------      # Increment age
      narw.indiv[[prj]][i, &quot;age&quot;, animals] &amp;lt;- alive * (current.dat[&quot;age&quot;, animals] + 1)      # Increment length
      newLp &amp;lt;- agL_vec(animals)      narw.indiv[[prj]][i,&quot;length_a&quot;, animals] &amp;lt;- 
        ifelse(narw.indiv[[prj]][i, &quot;age&quot;, animals] == 1, newLp[,1], current.dat[&quot;length_a&quot;, animals])      narw.indiv[[prj]][i,&quot;length_b&quot;, animals] &amp;lt;- 
        ifelse(narw.indiv[[prj]][i, &quot;age&quot;, animals] == 1, newLp[,2], current.dat[&quot;length_b&quot;, animals])      narw.indiv[[prj]][i,&quot;length_c&quot;, animals] &amp;lt;- 
        ifelse(narw.indiv[[prj]][i, &quot;age&quot;, animals] == 1, newLp[,3], current.dat[&quot;length_c&quot;, animals])      narw.indiv[[prj]][i, &quot;length&quot;, animals] &amp;lt;-
        alive * age2length_vec(
          narw.indiv[[prj]][i, &quot;age&quot;, animals],
          t(narw.indiv[[prj]][i, c(&quot;length_a&quot;, &quot;length_b&quot;, &quot;length_c&quot;), animals])
        )      # Increment lean mass
      narw.indiv[[prj]][i, &quot;lean_mass&quot;, animals] &amp;lt;- alive * length2mass_vec(narw.indiv[[prj]][i, &quot;length&quot;, animals],
                                                                            t(narw.indiv[[prj]][i, c(&quot;mass_a&quot;, &quot;mass_b&quot;), animals]), lean = TRUE)      # Predict new body condition from current body condition
      if (!spline) 
        narw.indiv[[prj]][i, &quot;bc&quot;, animals] &amp;lt;- alive * predict_m(
          model = mod, cohort = current.dat[&quot;cohort&quot;, animals],
          values = current.dat[&quot;bc&quot;, animals], prediction = &quot;bc&quot;)
       else 
        narw.indiv[[prj]][i, &quot;bc&quot;, animals] &amp;lt;-
          alive * (bc_preds[[&quot;0&quot;]](current.dat[&quot;bc&quot;, animals]) * (current.dat[&quot;cohort&quot;, animals] == 0) +
                     bc_preds[[&quot;1&quot;]](current.dat[&quot;bc&quot;, animals]) * (current.dat[&quot;cohort&quot;, animals] == 1) +
                     bc_preds[[&quot;2&quot;]](current.dat[&quot;bc&quot;, animals]) * (current.dat[&quot;cohort&quot;, animals] == 2) +
                     bc_preds[[&quot;3&quot;]](current.dat[&quot;bc&quot;, animals]) * (current.dat[&quot;cohort&quot;, animals] == 3) +
                     bc_preds[[&quot;4&quot;]](current.dat[&quot;bc&quot;, animals]) * (current.dat[&quot;cohort&quot;, animals] == 4) +
                     bc_preds[[&quot;5&quot;]](current.dat[&quot;bc&quot;, animals]) * (current.dat[&quot;cohort&quot;, animals] == 5) +
                     bc_preds[[&quot;6&quot;]](current.dat[&quot;bc&quot;, animals]) * (current.dat[&quot;cohort&quot;, animals] == 6))      # Increment total mass
      narw.indiv[[prj]][i, &quot;tot_mass&quot;, animals] &amp;lt;-
        alive * narw.indiv[[prj]][i, &quot;lean_mass&quot;, animals] / (1 - narw.indiv[[prj]][i, &quot;bc&quot;, animals])      #' ----------------------------
      # REPRODUCTION
      #' ----------------------------      # Which animals are resting females?
      rest.females &amp;lt;- (current.dat[&quot;cohort&quot;, animals] == 6)      # Which animals are juvenile females that are ready to start reproducing
      juvenile.females.ofage &amp;lt;- (current.dat[&quot;cohort&quot;, animals] == 2) * (current.dat[&quot;age&quot;, animals] &amp;gt;= 9)      # Which animals calved in previous step?
      prev.births &amp;lt;- current.dat[&quot;birth&quot;, animals]      newt2calf &amp;lt;- ifelse(prev.births == 1, random_int(sum(prev.births), lwr = 1), 
                          ifelse(current.dat[&quot;t2calf&quot;, animals] == 0, 0, 
                                 current.dat[&quot;t2calf&quot;, animals] - 1))      # Time spent in resting state - only incremented if calving event hasn't occurred, otherwise reset
      narw.indiv[[prj]][i, &quot;t2calf&quot;, animals] &amp;lt;- alive * rest.females * newt2calf      # Years until next calving event
      narw.indiv[[prj]][i, &quot;trest&quot;, animals] &amp;lt;- 
        alive * (rest.females | juvenile.females.ofage) * 
        ifelse(narw.indiv[[prj]][i - 1, &quot;trest&quot;, animals] == 13, 1, current.dat[&quot;trest&quot;, animals] + 1)      # Minimum body condition needed to successfully bring fetus to term without starving
      # No evidence of reproductive senescence in right whales - Hamilton et al. (1998)      if (!spline) 
        narw.indiv[[prj]][i, &quot;min_bc&quot;, animals] &amp;lt;-
          alive * predict_m(model = mod, values = narw.indiv[[prj]][i, &quot;tot_mass&quot;, animals], prediction = &quot;gest&quot;) * rest.females
       else 
        narw.indiv[[prj]][i, &quot;min_bc&quot;, animals] &amp;lt;-
          alive * mbc_preds(narw.indiv[[prj]][i, &quot;tot_mass&quot;, animals]) * rest.females      # Birth of new calf, conditional on the mother being alive, in pregnant state
      narw.indiv[[prj]][i, &quot;birth&quot;, animals] &amp;lt;- alive * (current.dat[&quot;cohort&quot;, animals] == 4)      # Maturity - transitions between cohorts
      narw.indiv[[prj]][i, &quot;cohort&quot;, animals] &amp;lt;-
        alive * increment_cohort(
          cohort = narw.indiv[[prj]][i - 1, &quot;cohort&quot;, animals],
          age = narw.indiv[[prj]][i, &quot;age&quot;, animals],
          female = narw.indiv[[prj]][i, &quot;female&quot;, animals],
          bc = narw.indiv[[prj]][i, &quot;bc&quot;, animals],
          min_bc = narw.indiv[[prj]][i, &quot;min_bc&quot;, animals],
          trest = narw.indiv[[prj]][i, &quot;trest&quot;, animals],
          t2calf = narw.indiv[[prj]][i, &quot;t2calf&quot;, animals])      new.births &amp;lt;- sum(narw.indiv[[prj]][i, &quot;birth&quot;, animals])      if(new.births &amp;gt; 0)
        narw.indiv[[prj]][i, , (max(animals)+1):(max(animals)+new.births)] &amp;lt;- add_calf(n = new.births, attr = mat.attribs)
        animals &amp;lt;- 1:(length(animals) + new.births)      # Number of animals in each cohort
      # Calves (male)
      narw.pop[prj, i, 1] &amp;lt;- sum((narw.indiv[[prj]][i, &quot;cohort&quot;, animals] == 0) *
                                   (narw.indiv[[prj]][i, &quot;female&quot;, animals] == 0) *
                                   (narw.indiv[[prj]][i, &quot;alive&quot;, animals] == 1))      # Juveniles and adults (male)
      narw.pop[prj, i, 2] &amp;lt;- sum((narw.indiv[[prj]][i, &quot;cohort&quot;, animals] == 1) * (narw.indiv[[prj]][i, &quot;alive&quot;, animals] == 1))
      narw.pop[prj, i, 3] &amp;lt;- sum((narw.indiv[[prj]][i, &quot;cohort&quot;, animals] == 3) * (narw.indiv[[prj]][i, &quot;alive&quot;, animals] == 1))      # Calves (female)
      narw.pop[prj, i, 4] &amp;lt;- sum((narw.indiv[[prj]][i, &quot;cohort&quot;, animals] == 0) *
                                   (narw.indiv[[prj]][i, &quot;female&quot;, animals] == 1) *
                                   (narw.indiv[[prj]][i, &quot;alive&quot;, animals] == 1))      # Juvenile and reproductive adults (female)
      narw.pop[prj, i, 5] &amp;lt;- sum((narw.indiv[[prj]][i, &quot;cohort&quot;, animals] == 2) * (narw.indiv[[prj]][i, &quot;alive&quot;, animals] == 1))
      narw.pop[prj, i, 6] &amp;lt;- sum((narw.indiv[[prj]][i, &quot;cohort&quot;, animals] == 4) * (narw.indiv[[prj]][i, &quot;alive&quot;, animals] == 1))
      narw.pop[prj, i, 7] &amp;lt;- sum((narw.indiv[[prj]][i, &quot;cohort&quot;, animals] == 5) * (narw.indiv[[prj]][i, &quot;alive&quot;, animals] == 1))
      narw.pop[prj, i, 8] &amp;lt;- sum((narw.indiv[[prj]][i, &quot;cohort&quot;, animals] == 6) * (narw.indiv[[prj]][i, &quot;alive&quot;, animals] == 1))      # Total population size
      tot.pop[prj, i] &amp;lt;- sum(narw.indiv[[prj]][i, &quot;alive&quot;, animals], na.rm = TRUE)     # End years
   # End projections  end.time &amp;lt;- Sys.time()
  run_time &amp;lt;- hms::round_hms(hms::as_hms(difftime(time1 = end.time, time2 = start.time, units = &quot;auto&quot;)), 1)  cat(&quot;Processing outputs ...&quot;)  # narw.out &amp;lt;- purrr::map(.x = 1:n, .f = ~
  #   reshape_array(narw.indiv[[.x]], value, yr, attr, whale) |&amp;gt; 
  #     dplyr::mutate(attr = mat.attribs[attr]) |&amp;gt; 
  #     tidyr::pivot_wider(names_from = attr, values_from = value) |&amp;gt; 
  #     dplyr::mutate(prj = .x) |&amp;gt; 
  #     dplyr::relocate(prj, .before = yr)
  # ) |&amp;gt; do.call(what = rbind) |&amp;gt; 
  #   data.table::data.table()  # narw.out &amp;lt;- narw.out[is.finite(rowSums(narw.out)),]  narw.df &amp;lt;- purrr::map(.x = cohorts$name, .f = ~
    narw.pop[,,.x] |&amp;gt; 
      tibble::as_tibble() |&amp;gt; 
      tibble::rownames_to_column(var = &quot;prj&quot;) |&amp;gt; 
      tidyr::pivot_longer(!prj, names_to = &quot;year&quot;, values_to = &quot;N&quot;) |&amp;gt; 
      dplyr::mutate(year = current.yr + as.numeric(gsub(&quot;yr &quot;, &quot;&quot;, year))) |&amp;gt; 
      dplyr::mutate(cohort = stringr::str_to_sentence(.x))
  ) |&amp;gt; do.call(what = rbind) |&amp;gt; data.table::data.table()  tot.df &amp;lt;- tibble::as_tibble(tot.pop) |&amp;gt; 
    tibble::rownames_to_column(var = &quot;prj&quot;) |&amp;gt; 
    tidyr::pivot_longer(!prj, names_to = &quot;year&quot;, values_to = &quot;N&quot;) |&amp;gt; 
    dplyr::mutate(year = current.yr + as.numeric(gsub(&quot;yr &quot;, &quot;&quot;, year))) |&amp;gt; 
    dplyr::mutate(cohort = &quot;North Atlantic right whales&quot;) |&amp;gt; data.table::data.table()  # births.df &amp;lt;- purrr::map(.x = 1:n, .f = ~
  #   m &amp;lt;- matrix(rowSums(narw.indiv[[.x]][2:(yrs+1),&quot;birth&quot;,], na.rm = TRUE), ncol = 1)
  #   colnames(m) &amp;lt;- .x
  #   m
  # ) |&amp;gt; do.call(what = cbind) |&amp;gt; 
  #   tibble::as_tibble() |&amp;gt; 
  #   tibble::rownames_to_column(var = &quot;year&quot;) |&amp;gt; 
  #   dplyr::mutate(year = as.numeric(year)) |&amp;gt; 
  #   tidyr::pivot_longer(!year, names_to = &quot;prj&quot;, values_to = &quot;birth&quot;) |&amp;gt; 
  #   dplyr::select(prj, year, birth) |&amp;gt; 
  #   dplyr::arrange(prj, year) |&amp;gt; 
  #   data.table::data.table()
  # 
  # deaths.df &amp;lt;- purrr::map(.x = 1:n, .f = ~
  #   m &amp;lt;- matrix(apply(X = narw.indiv[[.x]][2:(yrs+1),&quot;alive&quot;,],
  #                     MARGIN = 1,
  #                     FUN = function(x) 
  #     r &amp;lt;- x[!is.na(x)]
  #     r &amp;lt;- sum(r == 0)
  #     r
  #     ), ncol = 1)
  #   colnames(m) &amp;lt;- .x
  #   m
  # ) |&amp;gt; do.call(what = cbind) |&amp;gt;
  #   tibble::as_tibble() |&amp;gt;
  #   tibble::rownames_to_column(var = &quot;year&quot;) |&amp;gt;
  #   dplyr::mutate(year = as.numeric(year)) |&amp;gt;
  #   tidyr::pivot_longer(!year, names_to = &quot;prj&quot;, values_to = &quot;death&quot;) |&amp;gt;
  #   dplyr::select(prj, year, death) |&amp;gt;
  #   dplyr::arrange(prj, year) |&amp;gt;
  #   data.table::data.table()  narw.conf &amp;lt;- narw.df[
    , list(
      mean = mean(N),
      lwr = quantile(N, 0.025, na.rm = TRUE),
      uppr = quantile(N, 0.975, na.rm = TRUE)
    ),
    list(year, cohort)
  ] |&amp;gt;
    dplyr::mutate(cohort = factor(cohort, levels = c(
      &quot;Calves (male)&quot;,
      &quot;Calves (female)&quot;,
      &quot;Juveniles (male)&quot;,
      &quot;Juveniles (female)&quot;,
      &quot;Adults (male)&quot;,
      &quot;Adults (female, pregnant)&quot;,
      &quot;Adults (female, lactating)&quot;,
      &quot;Adults (female, resting)&quot;
    )))  tot.conf &amp;lt;- tot.df[
    , list(
      mean = mean(N),
      lwr = quantile(N, 0.025),
      uppr = quantile(N, 0.975)
    ),
    list(year, cohort)
  ] |&amp;gt;
    dplyr::mutate(cohort = factor(cohort, levels = c(
      &quot;Calves (male)&quot;,
      &quot;Calves (female)&quot;,
      &quot;Juveniles (male)&quot;,
      &quot;Juveniles (female)&quot;,
      &quot;Adults (male)&quot;,
      &quot;Adults (female, pregnant)&quot;,
      &quot;Adults (female, lactating)&quot;,
      &quot;Adults (female, resting)&quot;,
      &quot;North Atlantic right whales&quot;
    )))  p1 &amp;lt;- plot_projection(narw.df, narw.conf)
  p2 &amp;lt;- plot_projection(tot.df, tot.conf)  if(do.plot)
    print(p1)
    print(p2)  # Find 95
  cat(&quot;Final population size:&quot;)
  final.pop &amp;lt;- unname(tot.df[year == current.yr + yrs,  quantile(N, probs = c(0.5, 0.025, 0.975))])
  cat(&quot;N = &quot;, round(final.pop[1],0), &quot; (95  cat(paste0(&quot;Time elapsed: &quot;, run_time))
  cat(&quot;&quot;)  return(list(
    # dat = narw.out,
    out = list(df = rbind(narw.df, tot.df), 
               ci = rbind(narw.conf, tot.conf),
               plot = list(p1, p2))))"><!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body data-spy="scroll" data-target="#toc">
    

    <div class="container template-reference-topic">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">narwind</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="">1.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav"><li>
  <a href="../articles/narwind.html">Get started</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
    Articles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu"><li>
      <a href="../articles/narw_density.html">NARW density in Canada</a>
    </li>
  </ul></li>
      </ul><ul class="nav navbar-nav navbar-right"></ul></div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>predict_backup &lt;- function(obj,
         yrs = 35,
         n = 100,
         popr = 1,
         do.plot = FALSE,
         seed = 125897,
         ...) 
  
  set.seed(seed)
  
  if(sum(suppressWarnings(purrr::map_lgl(.x = obj$gam$pred, .f = ~any(is.na(.x)))) &gt; 0)) 
    stop("Insufficient sample size. Cannot make predictions.") 
  
  # Function ellipsis –– optional arguments
  args &lt;- list(...)
  
  # Default values
  if(length(args) == 0)
    spline &lt;- TRUE
    progress &lt;- TRUE
   else 
    if("spline" <!-- %in% names(args)) spline &lt;- args[["spline"]] else spline &lt;- TRUE -->
    if("progress" <!-- %in% names(args)) progress &lt;- args[["progress"]] else progress &lt;- TRUE -->
  
  
  cat("Initializing ...")
  
  # if(is.null(obj$gam)) stop("Insufficient data available. Cannot proceed with population projections.")
  # if(!identical(cohortID, 1:6)) stop("Missing cohorts in input &lt;obj&gt;. Cannot proceed with population projections.")
  # if(length(obj$gam$fit$surv$xlevels[[1]]) &lt; 6 | length(obj$gam$fit$bc$xlevels[[1]]) &lt; 6) stop("Missing factor levels in input &lt;obj&gt;. Cannot proceed with population projections.")
  
  # plogis("link" predictions + error)
  
  # Adapted from original code by Scott Creel
  # https://www.montana.edu/screel/teaching/bioe-440r-521/course-outline/stoch_projection_new.R
  # 
  # Prediction intervals
  # https://stat.ethz.ch/pipermail/r-help/2011-April/275632.html
  
  # Population estimate as per 2022 NARW report card is 340 (+/- 7).
  
  # test &lt;- mgcv::predict.gam(mod$gam[[1]]$surv, newdata = data.frame(start_bc = seq(0, find_maxBC(), 0.01)), type = "link", se.fit = TRUE)
  # plot(seq(0,find_maxBC(), 0.01), plogis(test$fit), type = "l")
  # lines(seq(0, find_maxBC(), 0.01), plogis(Reduce("+", test)), lty = 2)
  # lines(seq(0, find_maxBC(), 0.01), plogis(Reduce("-", test)), lty = 2)
  # test2 &lt;- mgcv::predict.gam(mod$gam[[1]]$surv, newdata = data.frame(start_bc = 0.2), type = "response")
  # abline(v = 0.2)
  # abline(h = tesct2)
  
  cohortID &lt;- obj$param$cohortID
  cohorts &lt;- obj$param$cohorts |&gt; dplyr::slice(1) |&gt; 
    dplyr::mutate(name = gsub(", female", "", name), abb = gsub(",f", "", abb)) |&gt; 
    dplyr::bind_rows(obj$param$cohorts) |&gt; 
    dplyr::mutate(name = gsub("male, female", "female", name), abb = gsub("m,f", "f", abb))
  cohorts &lt;- cohorts[c(1,3,5,2,4,6,7,8)]
  
  # Attributes to monitor during projection
  mat.attribs &lt;- c("alive", "cohort", "female", "age", "length", "length_a", "length_b", "length_c",
                   "tot_mass", "lean_mass", "bc", "mass_a", "mass_b", "p_surv", "min_bc", "trest", "t2calf", "birth")
  
  # Current year
  current.yr &lt;- lubridate::year(lubridate::now())
  
  # Extract terminal functions
  mod &lt;- obj$gam$fit
  mod[["gest"]] &lt;- gam_gest
  
  #'------------------------------------------------------
  # GAM PARAMETERS
  #'------------------------------------------------------
  
  mbc_preds &lt;- obj$gam$pred$bc_gest
  bc_preds &lt;- obj$gam$pred$bc
  surv_preds &lt;- obj$gam$pred$surv
  
  #'------------------------------------------------------
  # INITIALIZATION
  #'------------------------------------------------------
  
  # Define initial population vector
  # c(F1 = 0, F2 = 0, F3 = 2, F4 = 6, F5 = 4, F6 = 0, F7 = 6, F8 = 0, 
  # F9 = 5, "F10+" = 48, FC = 7, FR = 0, FB = 61, 
  # M1 = 0, M2 = 0, 
  # M3 = 2, M4 = 5, 
  # "M5+" = 212)
  N0 &lt;- c(0, 7, 212, 0, 71, 1, 7, 61)
  names(N0) &lt;- cohorts[, name]
  totn &lt;- sum(N0)* (1 + popr)
  
  cat("Setting up ...")
  
  # Create matrices and initialize them
  # rows: years &lt;yrs&gt;
  # columns: &lt;attributes&gt;
  # layers: individuals &lt;n&gt;
  # 4th dimension: replicate projection -&gt; later converted to list
  narw.indiv &lt;- array(data = NA, c(yrs + 1, length(mat.attribs), totn, n), 
                      dimnames = list(paste0("yr ", 0:yrs), 
                                      mat.attribs,
                                      paste0("whale ", 1:totn),
                                      paste0("prj ", 1:n)))
  
  cohort.vec &lt;- do.call(c, sapply(X = 1:nrow(cohorts), FUN = function(x) rep(cohorts$id[x], each = N0[x])))
  
  animals &lt;- 1:sum(N0)
  
  # Alive and population cohort
  narw.indiv[1, "alive", animals, ] &lt;- rep(1, )
  narw.indiv[1, "cohort", animals, ] &lt;- rep(cohort.vec, n)
  
  # Sex
  #  -- Calves (male)
  narw.indiv[, "female", 1:N0[1], ] &lt;- 0
  #  -- Calves (female)
  fem &lt;- which(cohort.vec == 0)
  narw.indiv[, "female", fem[fem &gt; N0[1]], ] &lt;- 1
  #  -- Juveniles and adults
  narw.indiv[, "female", which(cohort.vec <!-- %in% c(2, 4, 5, 6)), ] &lt;- 1 -->
  narw.indiv[, "female", which(cohort.vec <!-- %in% c(1, 3)), ] &lt;- 0 -->
  
  cat("Age ...")
  
  # Age
  ages &lt;- start_age_vec(rep(cohort.vec, n))
  narw.indiv[1, "age", animals, ] &lt;- ages
  
  cat("Length ...")
  
  # Total body length
  l.params &lt;- agL_vec(ages)
  lengths &lt;- age2length_vec(ages, l.params)
  narw.indiv[1, "length", animals, ] &lt;- lengths
  
  narw.indiv[, "length_a", animals, ] &lt;- rep(l.params[, 1], each = yrs + 1)
  narw.indiv[, "length_b", animals, ] &lt;- rep(l.params[, 2], each = yrs + 1)
  narw.indiv[, "length_c", animals, ] &lt;- rep(l.params[, 3], each = yrs + 1)
  
  cat("Mass ...")
  
  # Lean mass
  m.params &lt;- mL(n * sum(N0))
  narw.indiv[, "mass_a", animals, ] &lt;- rep(m.params[, 1], each = yrs + 1)
  narw.indiv[, "mass_b", animals, ] &lt;- rep(m.params[, 2], each = yrs + 1)
  mass &lt;- length2mass_vec(lengths, m.params)
  narw.indiv[1, "lean_mass", animals, ] &lt;- mass
  
  # Body conditon
  bc &lt;- start_bcondition_vec(rep(cohort.vec, n))
  narw.indiv[1, "bc", animals, ] &lt;- bc
  
  # Total mass
  narw.indiv[1, "tot_mass", animals, ] &lt;- mass / (1-bc)
  
  # Calving interval - mean of 5.3 years, up to apparent gaps of 13 years (Kraus et al. 2001)
  # NARWC Report Card 2022: Average inter-birth interval of 7.7 yrs, median of 8, min/max (2/13)
  # This corresponds to a Normal (7.7, 1.45)
  # Mean age at first calving = 9.53 +/- 2.32 (Kraus et al. 2001)
  # 
  # Stewart et al. 2022 -- 
  # The degree to which the energetic reserves of females are depleted during lactation may govern
  # the length of the resting period between successful pregnancies (Miller et al. 2011, Marón et al. 2015).
  
  cat("Reproduction ...")
  
  t2calf &lt;- (rep(cohort.vec, n) == 6) * random_int(sum(N0) * n)
  narw.indiv[1, "t2calf", animals, ] &lt;- t2calf
  narw.indiv[1, "trest", animals, ] &lt;- as.numeric(ifelse(t2calf == 0, 13, 1)) * (as.numeric(narw.indiv[1, "cohort", animals, ]) == 6)
  
  if (!spline) 
    narw.indiv[1, "min_bc", animals, ] &lt;- predict_m(
      model = mod,
      values = as.vector(narw.indiv[1, "tot_mass", animals, ]),
      prediction = "gest"
    ) * as.vector(narw.indiv[1, "cohort", animals, ] == 6)
   else 
    narw.indiv[1, "min_bc", animals, ] &lt;- mbc_preds(narw.indiv[1, "tot_mass", animals, ]) * (narw.indiv[1, "cohort", animals, ] == 6)
  
  
  narw.indiv[1, "birth", animals, ] &lt;- ifelse(narw.indiv[1, "trest", animals, ] == 13 &amp; narw.indiv[1, "t2calf", animals, ] == 0, 1, 0)
  narw.indiv[1, "p_surv", animals, ] &lt;- 1
  
  cat("List ...")
  
  #' ---------------------------
  # IMPORTANT 
  #' ---------------------------
  # Turn array into a list
  narw.indiv &lt;- purrr::array_branch(narw.indiv, 4) # bottleneck
  
  cat("totpop ...")
  
  # Number of individuals in each cohort
  narw.pop &lt;- array(
    data = NA, c(n, yrs + 1, nrow(cohorts)),
    dimnames = list(
      paste0("prj ", 1:n),
      paste0("yr ", 0:yrs),
      cohorts$name
    )
  )
  narw.pop[, 1, ] &lt;- rep(N0, each = n)
  
  cat("totpopinit ...")
  
  # Total population size
  tot.pop &lt;- matrix(0, n, yrs + 1, dimnames = list(paste0("prj", 1:n), paste0("yr ", 0:yrs)))
  tot.pop[, 1] &lt;- sum(N0)
  
  #'------------------------------------------------------
  # RUN PROJECTIONS
  #'------------------------------------------------------
  
  # This uses nested loops. 
  # The prj loop (outermost loop) replicates the projection &lt;n&gt; times.
  # The i loop is next, and steps across all years of projection from an initial population vector.
  
  # Set up progress bar
  pb &lt;- progress::progress_bar$new(
    format = "[:bar] :percent eta: :eta",
    total = n, clear = FALSE, width = 80
  )
  
  cat("Running projections ...")
  start.time &lt;- Sys.time()
  
  for(prj in 1:n)
    
    if(progress) pb$tick() # Update progress bar
    
    animals &lt;- 1:sum(N0)
    
    #'------------------------------------------------------
    # Loop over years
    #'------------------------------------------------------
    
    for(i in 2:(yrs+1))
      
      current.dat &lt;- as.matrix(narw.indiv[[prj]][i-1, , animals])
      alive &lt;- current.dat["alive", animals] * (current.dat["age", animals] &lt;=69)
      
      #' ----------------------------
      # SURVIVAL
      #' ----------------------------
      # Predict survival probability based on body condition
      
      if(!spline)
        
        ps &lt;- alive * predict_m(model = mod, cohort = current.dat["cohort",animals], 
                                values = current.dat["bc",animals], prediction = "surv")
        
       else 
        
        ps &lt;- alive * (surv_preds[["0"]](current.dat["bc",animals]) * (current.dat["cohort",animals] == 0) +
                         surv_preds[["1"]](current.dat["bc",animals]) * (current.dat["cohort",animals] == 1) +
                         surv_preds[["2"]](current.dat["bc",animals]) * (current.dat["cohort",animals] == 2) +
                         surv_preds[["3"]](current.dat["bc",animals]) * (current.dat["cohort",animals] == 3) +
                         surv_preds[["4"]](current.dat["bc",animals]) * (current.dat["cohort",animals] == 4) +
                         surv_preds[["5"]](current.dat["bc",animals]) * (current.dat["cohort",animals] == 5) +
                         surv_preds[["6"]](current.dat["bc",animals]) * (current.dat["cohort",animals] == 6))
      
      
      # ps &lt;- 1
      narw.indiv[[prj]][i, "p_surv", animals] &lt;- ps
      
      # Determine whether the animal survived
      alive &lt;- rbinom(n = animals, size = 1, prob = ps) * (current.dat["age", animals] &lt;=69)
      narw.indiv[[prj]][i, "alive", animals] &lt;- alive
      
      # Sex remains the same
      narw.indiv[[prj]][i, "female", animals] &lt;- current.dat["female", animals]
      
      #' ----------------------------
      # GROWTH
      #' ----------------------------
      
      # Increment age
      narw.indiv[[prj]][i, "age", animals] &lt;- alive * (current.dat["age", animals] + 1)
      
      # Increment length
      newLp &lt;- agL_vec(animals)
      
      narw.indiv[[prj]][i,"length_a", animals] &lt;- 
        ifelse(narw.indiv[[prj]][i, "age", animals] == 1, newLp[,1], current.dat["length_a", animals])
      
      narw.indiv[[prj]][i,"length_b", animals] &lt;- 
        ifelse(narw.indiv[[prj]][i, "age", animals] == 1, newLp[,2], current.dat["length_b", animals])
      
      narw.indiv[[prj]][i,"length_c", animals] &lt;- 
        ifelse(narw.indiv[[prj]][i, "age", animals] == 1, newLp[,3], current.dat["length_c", animals])
      
      narw.indiv[[prj]][i, "length", animals] &lt;-
        alive * age2length_vec(
          narw.indiv[[prj]][i, "age", animals],
          t(narw.indiv[[prj]][i, c("length_a", "length_b", "length_c"), animals])
        )
      
      # Increment lean mass
      narw.indiv[[prj]][i, "lean_mass", animals] &lt;- alive * length2mass_vec(narw.indiv[[prj]][i, "length", animals],
                                                                            t(narw.indiv[[prj]][i, c("mass_a", "mass_b"), animals]), lean = TRUE)
      
      # Predict new body condition from current body condition
      if (!spline) 
        narw.indiv[[prj]][i, "bc", animals] &lt;- alive * predict_m(
          model = mod, cohort = current.dat["cohort", animals],
          values = current.dat["bc", animals], prediction = "bc")
       else 
        narw.indiv[[prj]][i, "bc", animals] &lt;-
          alive * (bc_preds[["0"]](current.dat["bc", animals]) * (current.dat["cohort", animals] == 0) +
                     bc_preds[["1"]](current.dat["bc", animals]) * (current.dat["cohort", animals] == 1) +
                     bc_preds[["2"]](current.dat["bc", animals]) * (current.dat["cohort", animals] == 2) +
                     bc_preds[["3"]](current.dat["bc", animals]) * (current.dat["cohort", animals] == 3) +
                     bc_preds[["4"]](current.dat["bc", animals]) * (current.dat["cohort", animals] == 4) +
                     bc_preds[["5"]](current.dat["bc", animals]) * (current.dat["cohort", animals] == 5) +
                     bc_preds[["6"]](current.dat["bc", animals]) * (current.dat["cohort", animals] == 6))
      
      
      # Increment total mass
      narw.indiv[[prj]][i, "tot_mass", animals] &lt;-
        alive * narw.indiv[[prj]][i, "lean_mass", animals] / (1 - narw.indiv[[prj]][i, "bc", animals])
      
      #' ----------------------------
      # REPRODUCTION
      #' ----------------------------
      
      # Which animals are resting females?
      rest.females &lt;- (current.dat["cohort", animals] == 6)
      
      # Which animals are juvenile females that are ready to start reproducing
      juvenile.females.ofage &lt;- (current.dat["cohort", animals] == 2) * (current.dat["age", animals] &gt;= 9)
      
      # Which animals calved in previous step?
      prev.births &lt;- current.dat["birth", animals]
      
      newt2calf &lt;- ifelse(prev.births == 1, random_int(sum(prev.births), lwr = 1), 
                          ifelse(current.dat["t2calf", animals] == 0, 0, 
                                 current.dat["t2calf", animals] - 1))
      
      # Time spent in resting state - only incremented if calving event hasn't occurred, otherwise reset
      narw.indiv[[prj]][i, "t2calf", animals] &lt;- alive * rest.females * newt2calf
      
      # Years until next calving event
      narw.indiv[[prj]][i, "trest", animals] &lt;- 
        alive * (rest.females | juvenile.females.ofage) * 
        ifelse(narw.indiv[[prj]][i - 1, "trest", animals] == 13, 1, current.dat["trest", animals] + 1)
      
      # Minimum body condition needed to successfully bring fetus to term without starving
      # No evidence of reproductive senescence in right whales - Hamilton et al. (1998)
      
      if (!spline) 
        narw.indiv[[prj]][i, "min_bc", animals] &lt;-
          alive * predict_m(model = mod, values = narw.indiv[[prj]][i, "tot_mass", animals], prediction = "gest") * rest.females
       else 
        narw.indiv[[prj]][i, "min_bc", animals] &lt;-
          alive * mbc_preds(narw.indiv[[prj]][i, "tot_mass", animals]) * rest.females
      
      
      # Birth of new calf, conditional on the mother being alive, in pregnant state
      narw.indiv[[prj]][i, "birth", animals] &lt;- alive * (current.dat["cohort", animals] == 4)
      
      # Maturity - transitions between cohorts
      narw.indiv[[prj]][i, "cohort", animals] &lt;-
        alive * increment_cohort(
          cohort = narw.indiv[[prj]][i - 1, "cohort", animals],
          age = narw.indiv[[prj]][i, "age", animals],
          female = narw.indiv[[prj]][i, "female", animals],
          bc = narw.indiv[[prj]][i, "bc", animals],
          min_bc = narw.indiv[[prj]][i, "min_bc", animals],
          trest = narw.indiv[[prj]][i, "trest", animals],
          t2calf = narw.indiv[[prj]][i, "t2calf", animals])
      
      new.births &lt;- sum(narw.indiv[[prj]][i, "birth", animals])
      
      if(new.births &gt; 0)
        narw.indiv[[prj]][i, , (max(animals)+1):(max(animals)+new.births)] &lt;- add_calf(n = new.births, attr = mat.attribs)
        animals &lt;- 1:(length(animals) + new.births)
      
      
      # Number of animals in each cohort
      # Calves (male)
      narw.pop[prj, i, 1] &lt;- sum((narw.indiv[[prj]][i, "cohort", animals] == 0) *
                                   (narw.indiv[[prj]][i, "female", animals] == 0) *
                                   (narw.indiv[[prj]][i, "alive", animals] == 1))
      
      # Juveniles and adults (male)
      narw.pop[prj, i, 2] &lt;- sum((narw.indiv[[prj]][i, "cohort", animals] == 1) * (narw.indiv[[prj]][i, "alive", animals] == 1))
      narw.pop[prj, i, 3] &lt;- sum((narw.indiv[[prj]][i, "cohort", animals] == 3) * (narw.indiv[[prj]][i, "alive", animals] == 1))
      
      # Calves (female)
      narw.pop[prj, i, 4] &lt;- sum((narw.indiv[[prj]][i, "cohort", animals] == 0) *
                                   (narw.indiv[[prj]][i, "female", animals] == 1) *
                                   (narw.indiv[[prj]][i, "alive", animals] == 1))
      
      # Juvenile and reproductive adults (female)
      narw.pop[prj, i, 5] &lt;- sum((narw.indiv[[prj]][i, "cohort", animals] == 2) * (narw.indiv[[prj]][i, "alive", animals] == 1))
      narw.pop[prj, i, 6] &lt;- sum((narw.indiv[[prj]][i, "cohort", animals] == 4) * (narw.indiv[[prj]][i, "alive", animals] == 1))
      narw.pop[prj, i, 7] &lt;- sum((narw.indiv[[prj]][i, "cohort", animals] == 5) * (narw.indiv[[prj]][i, "alive", animals] == 1))
      narw.pop[prj, i, 8] &lt;- sum((narw.indiv[[prj]][i, "cohort", animals] == 6) * (narw.indiv[[prj]][i, "alive", animals] == 1))
      
      # Total population size
      tot.pop[prj, i] &lt;- sum(narw.indiv[[prj]][i, "alive", animals], na.rm = TRUE)
      
     # End years
   # End projections
  
  end.time &lt;- Sys.time()
  run_time &lt;- hms::round_hms(hms::as_hms(difftime(time1 = end.time, time2 = start.time, units = "auto")), 1)
  
  cat("Processing outputs ...")
  
  # narw.out &lt;- purrr::map(.x = 1:n, .f = ~
  #   reshape_array(narw.indiv[[.x]], value, yr, attr, whale) |&gt; 
  #     dplyr::mutate(attr = mat.attribs[attr]) |&gt; 
  #     tidyr::pivot_wider(names_from = attr, values_from = value) |&gt; 
  #     dplyr::mutate(prj = .x) |&gt; 
  #     dplyr::relocate(prj, .before = yr)
  # ) |&gt; do.call(what = rbind) |&gt; 
  #   data.table::data.table()
  
  # narw.out &lt;- narw.out[is.finite(rowSums(narw.out)),]
  
  narw.df &lt;- purrr::map(.x = cohorts$name, .f = ~
    narw.pop[,,.x] |&gt; 
      tibble::as_tibble() |&gt; 
      tibble::rownames_to_column(var = "prj") |&gt; 
      tidyr::pivot_longer(!prj, names_to = "year", values_to = "N") |&gt; 
      dplyr::mutate(year = current.yr + as.numeric(gsub("yr ", "", year))) |&gt; 
      dplyr::mutate(cohort = stringr::str_to_sentence(.x))
  ) |&gt; do.call(what = rbind) |&gt; data.table::data.table()
  
  tot.df &lt;- tibble::as_tibble(tot.pop) |&gt; 
    tibble::rownames_to_column(var = "prj") |&gt; 
    tidyr::pivot_longer(!prj, names_to = "year", values_to = "N") |&gt; 
    dplyr::mutate(year = current.yr + as.numeric(gsub("yr ", "", year))) |&gt; 
    dplyr::mutate(cohort = "North Atlantic right whales") |&gt; data.table::data.table()
  
  # births.df &lt;- purrr::map(.x = 1:n, .f = ~
  #   m &lt;- matrix(rowSums(narw.indiv[[.x]][2:(yrs+1),"birth",], na.rm = TRUE), ncol = 1)
  #   colnames(m) &lt;- .x
  #   m
  # ) |&gt; do.call(what = cbind) |&gt; 
  #   tibble::as_tibble() |&gt; 
  #   tibble::rownames_to_column(var = "year") |&gt; 
  #   dplyr::mutate(year = as.numeric(year)) |&gt; 
  #   tidyr::pivot_longer(!year, names_to = "prj", values_to = "birth") |&gt; 
  #   dplyr::select(prj, year, birth) |&gt; 
  #   dplyr::arrange(prj, year) |&gt; 
  #   data.table::data.table()
  # 
  # deaths.df &lt;- purrr::map(.x = 1:n, .f = ~
  #   m &lt;- matrix(apply(X = narw.indiv[[.x]][2:(yrs+1),"alive",],
  #                     MARGIN = 1,
  #                     FUN = function(x) 
  #     r &lt;- x[!is.na(x)]
  #     r &lt;- sum(r == 0)
  #     r
  #     ), ncol = 1)
  #   colnames(m) &lt;- .x
  #   m
  # ) |&gt; do.call(what = cbind) |&gt;
  #   tibble::as_tibble() |&gt;
  #   tibble::rownames_to_column(var = "year") |&gt;
  #   dplyr::mutate(year = as.numeric(year)) |&gt;
  #   tidyr::pivot_longer(!year, names_to = "prj", values_to = "death") |&gt;
  #   dplyr::select(prj, year, death) |&gt;
  #   dplyr::arrange(prj, year) |&gt;
  #   data.table::data.table()
  
  narw.conf &lt;- narw.df[
    , list(
      mean = mean(N),
      lwr = quantile(N, 0.025, na.rm = TRUE),
      uppr = quantile(N, 0.975, na.rm = TRUE)
    ),
    list(year, cohort)
  ] |&gt;
    dplyr::mutate(cohort = factor(cohort, levels = c(
      "Calves (male)",
      "Calves (female)",
      "Juveniles (male)",
      "Juveniles (female)",
      "Adults (male)",
      "Adults (female, pregnant)",
      "Adults (female, lactating)",
      "Adults (female, resting)"
    )))
  
  tot.conf &lt;- tot.df[
    , list(
      mean = mean(N),
      lwr = quantile(N, 0.025),
      uppr = quantile(N, 0.975)
    ),
    list(year, cohort)
  ] |&gt;
    dplyr::mutate(cohort = factor(cohort, levels = c(
      "Calves (male)",
      "Calves (female)",
      "Juveniles (male)",
      "Juveniles (female)",
      "Adults (male)",
      "Adults (female, pregnant)",
      "Adults (female, lactating)",
      "Adults (female, resting)",
      "North Atlantic right whales"
    )))
  
  p1 &lt;- plot_projection(narw.df, narw.conf)
  p2 &lt;- plot_projection(tot.df, tot.conf)
  
  if(do.plot)
    print(p1)
    print(p2)
  
  
  # Find 95<!-- % confidence intervals on final population size -->
  cat("Final population size:")
  final.pop &lt;- unname(tot.df[year == current.yr + yrs,  quantile(N, probs = c(0.5, 0.025, 0.975))])
  cat("N = ", round(final.pop[1],0), " (95<!-- % CI: ", round(final.pop[2],0), "–", round(final.pop[3],0), ")\n", sep = "") -->
  
  cat(paste0("Time elapsed: ", run_time))
  cat("")
  
  return(list(
    # dat = narw.out,
    out = list(df = rbind(narw.df, tot.df), 
               ci = rbind(narw.conf, tot.conf),
               plot = list(p1, p2))))</h1>
    
    <div class="hidden name"><code>predict_m.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>predict_backup &lt;- function(obj,
         yrs = 35,
         n = 100,
         popr = 1,
         do.plot = FALSE,
         seed = 125897,
         ...)   set.seed(seed)  if(sum(suppressWarnings(purrr::map_lgl(.x = obj$gam$pred, .f = ~any(is.na(.x)))) &gt; 0)) 
    stop("Insufficient sample size. Cannot make predictions.")   # Function ellipsis –– optional arguments
  args &lt;- list(...)  # Default values
  if(length(args) == 0)
    spline &lt;- TRUE
    progress &lt;- TRUE
   else 
    if("spline" <!-- %in% names(args)) spline &lt;- args[["spline"]] else spline &lt;- TRUE -->
    if("progress" <!-- %in% names(args)) progress &lt;- args[["progress"]] else progress &lt;- TRUE -->  cat("Initializing ...")  # if(is.null(obj$gam)) stop("Insufficient data available. Cannot proceed with population projections.")
  # if(!identical(cohortID, 1:6)) stop("Missing cohorts in input &lt;obj&gt;. Cannot proceed with population projections.")
  # if(length(obj$gam$fit$surv$xlevels[[1]]) &lt; 6 | length(obj$gam$fit$bc$xlevels[[1]]) &lt; 6) stop("Missing factor levels in input &lt;obj&gt;. Cannot proceed with population projections.")  # plogis("link" predictions + error)  # Adapted from original code by Scott Creel
  # https://www.montana.edu/screel/teaching/bioe-440r-521/course-outline/stoch_projection_new.R
  # 
  # Prediction intervals
  # https://stat.ethz.ch/pipermail/r-help/2011-April/275632.html  # Population estimate as per 2022 NARW report card is 340 (+/- 7).  # test &lt;- mgcv::predict.gam(mod$gam[[1]]$surv, newdata = data.frame(start_bc = seq(0, find_maxBC(), 0.01)), type = "link", se.fit = TRUE)
  # plot(seq(0,find_maxBC(), 0.01), plogis(test$fit), type = "l")
  # lines(seq(0, find_maxBC(), 0.01), plogis(Reduce("+", test)), lty = 2)
  # lines(seq(0, find_maxBC(), 0.01), plogis(Reduce("-", test)), lty = 2)
  # test2 &lt;- mgcv::predict.gam(mod$gam[[1]]$surv, newdata = data.frame(start_bc = 0.2), type = "response")
  # abline(v = 0.2)
  # abline(h = tesct2)  cohortID &lt;- obj$param$cohortID
  cohorts &lt;- obj$param$cohorts |&gt; dplyr::slice(1) |&gt; 
    dplyr::mutate(name = gsub(", female", "", name), abb = gsub(",f", "", abb)) |&gt; 
    dplyr::bind_rows(obj$param$cohorts) |&gt; 
    dplyr::mutate(name = gsub("male, female", "female", name), abb = gsub("m,f", "f", abb))
  cohorts &lt;- cohorts[c(1,3,5,2,4,6,7,8)]  # Attributes to monitor during projection
  mat.attribs &lt;- c("alive", "cohort", "female", "age", "length", "length_a", "length_b", "length_c",
                   "tot_mass", "lean_mass", "bc", "mass_a", "mass_b", "p_surv", "min_bc", "trest", "t2calf", "birth")  # Current year
  current.yr &lt;- lubridate::year(lubridate::now())  # Extract terminal functions
  mod &lt;- obj$gam$fit
  mod[["gest"]] &lt;- gam_gest  #'------------------------------------------------------
  # GAM PARAMETERS
  #'------------------------------------------------------  mbc_preds &lt;- obj$gam$pred$bc_gest
  bc_preds &lt;- obj$gam$pred$bc
  surv_preds &lt;- obj$gam$pred$surv  #'------------------------------------------------------
  # INITIALIZATION
  #'------------------------------------------------------  # Define initial population vector
  # c(F1 = 0, F2 = 0, F3 = 2, F4 = 6, F5 = 4, F6 = 0, F7 = 6, F8 = 0, 
  # F9 = 5, "F10+" = 48, FC = 7, FR = 0, FB = 61, 
  # M1 = 0, M2 = 0, 
  # M3 = 2, M4 = 5, 
  # "M5+" = 212)
  N0 &lt;- c(0, 7, 212, 0, 71, 1, 7, 61)
  names(N0) &lt;- cohorts[, name]
  totn &lt;- sum(N0)* (1 + popr)  cat("Setting up ...")  # Create matrices and initialize them
  # rows: years &lt;yrs&gt;
  # columns: &lt;attributes&gt;
  # layers: individuals &lt;n&gt;
  # 4th dimension: replicate projection -&gt; later converted to list
  narw.indiv &lt;- array(data = NA, c(yrs + 1, length(mat.attribs), totn, n), 
                      dimnames = list(paste0("yr ", 0:yrs), 
                                      mat.attribs,
                                      paste0("whale ", 1:totn),
                                      paste0("prj ", 1:n)))  cohort.vec &lt;- do.call(c, sapply(X = 1:nrow(cohorts), FUN = function(x) rep(cohorts$id[x], each = N0[x])))  animals &lt;- 1:sum(N0)  # Alive and population cohort
  narw.indiv[1, "alive", animals, ] &lt;- rep(1, )
  narw.indiv[1, "cohort", animals, ] &lt;- rep(cohort.vec, n)  # Sex
  #  -- Calves (male)
  narw.indiv[, "female", 1:N0[1], ] &lt;- 0
  #  -- Calves (female)
  fem &lt;- which(cohort.vec == 0)
  narw.indiv[, "female", fem[fem &gt; N0[1]], ] &lt;- 1
  #  -- Juveniles and adults
  narw.indiv[, "female", which(cohort.vec <!-- %in% c(2, 4, 5, 6)), ] &lt;- 1 -->
  narw.indiv[, "female", which(cohort.vec <!-- %in% c(1, 3)), ] &lt;- 0 -->  cat("Age ...")  # Age
  ages &lt;- start_age_vec(rep(cohort.vec, n))
  narw.indiv[1, "age", animals, ] &lt;- ages  cat("Length ...")  # Total body length
  l.params &lt;- agL_vec(ages)
  lengths &lt;- age2length_vec(ages, l.params)
  narw.indiv[1, "length", animals, ] &lt;- lengths  narw.indiv[, "length_a", animals, ] &lt;- rep(l.params[, 1], each = yrs + 1)
  narw.indiv[, "length_b", animals, ] &lt;- rep(l.params[, 2], each = yrs + 1)
  narw.indiv[, "length_c", animals, ] &lt;- rep(l.params[, 3], each = yrs + 1)  cat("Mass ...")  # Lean mass
  m.params &lt;- mL(n * sum(N0))
  narw.indiv[, "mass_a", animals, ] &lt;- rep(m.params[, 1], each = yrs + 1)
  narw.indiv[, "mass_b", animals, ] &lt;- rep(m.params[, 2], each = yrs + 1)
  mass &lt;- length2mass_vec(lengths, m.params)
  narw.indiv[1, "lean_mass", animals, ] &lt;- mass  # Body conditon
  bc &lt;- start_bcondition_vec(rep(cohort.vec, n))
  narw.indiv[1, "bc", animals, ] &lt;- bc  # Total mass
  narw.indiv[1, "tot_mass", animals, ] &lt;- mass / (1-bc)  # Calving interval - mean of 5.3 years, up to apparent gaps of 13 years (Kraus et al. 2001)
  # NARWC Report Card 2022: Average inter-birth interval of 7.7 yrs, median of 8, min/max (2/13)
  # This corresponds to a Normal (7.7, 1.45)
  # Mean age at first calving = 9.53 +/- 2.32 (Kraus et al. 2001)
  # 
  # Stewart et al. 2022 -- 
  # The degree to which the energetic reserves of females are depleted during lactation may govern
  # the length of the resting period between successful pregnancies (Miller et al. 2011, Marón et al. 2015).  cat("Reproduction ...")  t2calf &lt;- (rep(cohort.vec, n) == 6) * random_int(sum(N0) * n)
  narw.indiv[1, "t2calf", animals, ] &lt;- t2calf
  narw.indiv[1, "trest", animals, ] &lt;- as.numeric(ifelse(t2calf == 0, 13, 1)) * (as.numeric(narw.indiv[1, "cohort", animals, ]) == 6)  if (!spline) 
    narw.indiv[1, "min_bc", animals, ] &lt;- predict_m(
      model = mod,
      values = as.vector(narw.indiv[1, "tot_mass", animals, ]),
      prediction = "gest"
    ) * as.vector(narw.indiv[1, "cohort", animals, ] == 6)
   else 
    narw.indiv[1, "min_bc", animals, ] &lt;- mbc_preds(narw.indiv[1, "tot_mass", animals, ]) * (narw.indiv[1, "cohort", animals, ] == 6)  narw.indiv[1, "birth", animals, ] &lt;- ifelse(narw.indiv[1, "trest", animals, ] == 13 &amp; narw.indiv[1, "t2calf", animals, ] == 0, 1, 0)
  narw.indiv[1, "p_surv", animals, ] &lt;- 1  cat("List ...")  #' ---------------------------
  # IMPORTANT 
  #' ---------------------------
  # Turn array into a list
  narw.indiv &lt;- purrr::array_branch(narw.indiv, 4) # bottleneck  cat("totpop ...")  # Number of individuals in each cohort
  narw.pop &lt;- array(
    data = NA, c(n, yrs + 1, nrow(cohorts)),
    dimnames = list(
      paste0("prj ", 1:n),
      paste0("yr ", 0:yrs),
      cohorts$name
    )
  )
  narw.pop[, 1, ] &lt;- rep(N0, each = n)  cat("totpopinit ...")  # Total population size
  tot.pop &lt;- matrix(0, n, yrs + 1, dimnames = list(paste0("prj", 1:n), paste0("yr ", 0:yrs)))
  tot.pop[, 1] &lt;- sum(N0)  #'------------------------------------------------------
  # RUN PROJECTIONS
  #'------------------------------------------------------  # This uses nested loops. 
  # The prj loop (outermost loop) replicates the projection &lt;n&gt; times.
  # The i loop is next, and steps across all years of projection from an initial population vector.  # Set up progress bar
  pb &lt;- progress::progress_bar$new(
    format = "[:bar] :percent eta: :eta",
    total = n, clear = FALSE, width = 80
  )  cat("Running projections ...")
  start.time &lt;- Sys.time()  for(prj in 1:n)    if(progress) pb$tick() # Update progress bar    animals &lt;- 1:sum(N0)    #'------------------------------------------------------
    # Loop over years
    #'------------------------------------------------------    for(i in 2:(yrs+1))      current.dat &lt;- as.matrix(narw.indiv[[prj]][i-1, , animals])
      alive &lt;- current.dat["alive", animals] * (current.dat["age", animals] &lt;=69)      #' ----------------------------
      # SURVIVAL
      #' ----------------------------
      # Predict survival probability based on body condition      if(!spline)        ps &lt;- alive * predict_m(model = mod, cohort = current.dat["cohort",animals], 
                                values = current.dat["bc",animals], prediction = "surv")       else         ps &lt;- alive * (surv_preds[["0"]](current.dat["bc",animals]) * (current.dat["cohort",animals] == 0) +
                         surv_preds[["1"]](current.dat["bc",animals]) * (current.dat["cohort",animals] == 1) +
                         surv_preds[["2"]](current.dat["bc",animals]) * (current.dat["cohort",animals] == 2) +
                         surv_preds[["3"]](current.dat["bc",animals]) * (current.dat["cohort",animals] == 3) +
                         surv_preds[["4"]](current.dat["bc",animals]) * (current.dat["cohort",animals] == 4) +
                         surv_preds[["5"]](current.dat["bc",animals]) * (current.dat["cohort",animals] == 5) +
                         surv_preds[["6"]](current.dat["bc",animals]) * (current.dat["cohort",animals] == 6))      # ps &lt;- 1
      narw.indiv[[prj]][i, "p_surv", animals] &lt;- ps      # Determine whether the animal survived
      alive &lt;- rbinom(n = animals, size = 1, prob = ps) * (current.dat["age", animals] &lt;=69)
      narw.indiv[[prj]][i, "alive", animals] &lt;- alive      # Sex remains the same
      narw.indiv[[prj]][i, "female", animals] &lt;- current.dat["female", animals]      #' ----------------------------
      # GROWTH
      #' ----------------------------      # Increment age
      narw.indiv[[prj]][i, "age", animals] &lt;- alive * (current.dat["age", animals] + 1)      # Increment length
      newLp &lt;- agL_vec(animals)      narw.indiv[[prj]][i,"length_a", animals] &lt;- 
        ifelse(narw.indiv[[prj]][i, "age", animals] == 1, newLp[,1], current.dat["length_a", animals])      narw.indiv[[prj]][i,"length_b", animals] &lt;- 
        ifelse(narw.indiv[[prj]][i, "age", animals] == 1, newLp[,2], current.dat["length_b", animals])      narw.indiv[[prj]][i,"length_c", animals] &lt;- 
        ifelse(narw.indiv[[prj]][i, "age", animals] == 1, newLp[,3], current.dat["length_c", animals])      narw.indiv[[prj]][i, "length", animals] &lt;-
        alive * age2length_vec(
          narw.indiv[[prj]][i, "age", animals],
          t(narw.indiv[[prj]][i, c("length_a", "length_b", "length_c"), animals])
        )      # Increment lean mass
      narw.indiv[[prj]][i, "lean_mass", animals] &lt;- alive * length2mass_vec(narw.indiv[[prj]][i, "length", animals],
                                                                            t(narw.indiv[[prj]][i, c("mass_a", "mass_b"), animals]), lean = TRUE)      # Predict new body condition from current body condition
      if (!spline) 
        narw.indiv[[prj]][i, "bc", animals] &lt;- alive * predict_m(
          model = mod, cohort = current.dat["cohort", animals],
          values = current.dat["bc", animals], prediction = "bc")
       else 
        narw.indiv[[prj]][i, "bc", animals] &lt;-
          alive * (bc_preds[["0"]](current.dat["bc", animals]) * (current.dat["cohort", animals] == 0) +
                     bc_preds[["1"]](current.dat["bc", animals]) * (current.dat["cohort", animals] == 1) +
                     bc_preds[["2"]](current.dat["bc", animals]) * (current.dat["cohort", animals] == 2) +
                     bc_preds[["3"]](current.dat["bc", animals]) * (current.dat["cohort", animals] == 3) +
                     bc_preds[["4"]](current.dat["bc", animals]) * (current.dat["cohort", animals] == 4) +
                     bc_preds[["5"]](current.dat["bc", animals]) * (current.dat["cohort", animals] == 5) +
                     bc_preds[["6"]](current.dat["bc", animals]) * (current.dat["cohort", animals] == 6))      # Increment total mass
      narw.indiv[[prj]][i, "tot_mass", animals] &lt;-
        alive * narw.indiv[[prj]][i, "lean_mass", animals] / (1 - narw.indiv[[prj]][i, "bc", animals])      #' ----------------------------
      # REPRODUCTION
      #' ----------------------------      # Which animals are resting females?
      rest.females &lt;- (current.dat["cohort", animals] == 6)      # Which animals are juvenile females that are ready to start reproducing
      juvenile.females.ofage &lt;- (current.dat["cohort", animals] == 2) * (current.dat["age", animals] &gt;= 9)      # Which animals calved in previous step?
      prev.births &lt;- current.dat["birth", animals]      newt2calf &lt;- ifelse(prev.births == 1, random_int(sum(prev.births), lwr = 1), 
                          ifelse(current.dat["t2calf", animals] == 0, 0, 
                                 current.dat["t2calf", animals] - 1))      # Time spent in resting state - only incremented if calving event hasn't occurred, otherwise reset
      narw.indiv[[prj]][i, "t2calf", animals] &lt;- alive * rest.females * newt2calf      # Years until next calving event
      narw.indiv[[prj]][i, "trest", animals] &lt;- 
        alive * (rest.females | juvenile.females.ofage) * 
        ifelse(narw.indiv[[prj]][i - 1, "trest", animals] == 13, 1, current.dat["trest", animals] + 1)      # Minimum body condition needed to successfully bring fetus to term without starving
      # No evidence of reproductive senescence in right whales - Hamilton et al. (1998)      if (!spline) 
        narw.indiv[[prj]][i, "min_bc", animals] &lt;-
          alive * predict_m(model = mod, values = narw.indiv[[prj]][i, "tot_mass", animals], prediction = "gest") * rest.females
       else 
        narw.indiv[[prj]][i, "min_bc", animals] &lt;-
          alive * mbc_preds(narw.indiv[[prj]][i, "tot_mass", animals]) * rest.females      # Birth of new calf, conditional on the mother being alive, in pregnant state
      narw.indiv[[prj]][i, "birth", animals] &lt;- alive * (current.dat["cohort", animals] == 4)      # Maturity - transitions between cohorts
      narw.indiv[[prj]][i, "cohort", animals] &lt;-
        alive * increment_cohort(
          cohort = narw.indiv[[prj]][i - 1, "cohort", animals],
          age = narw.indiv[[prj]][i, "age", animals],
          female = narw.indiv[[prj]][i, "female", animals],
          bc = narw.indiv[[prj]][i, "bc", animals],
          min_bc = narw.indiv[[prj]][i, "min_bc", animals],
          trest = narw.indiv[[prj]][i, "trest", animals],
          t2calf = narw.indiv[[prj]][i, "t2calf", animals])      new.births &lt;- sum(narw.indiv[[prj]][i, "birth", animals])      if(new.births &gt; 0)
        narw.indiv[[prj]][i, , (max(animals)+1):(max(animals)+new.births)] &lt;- add_calf(n = new.births, attr = mat.attribs)
        animals &lt;- 1:(length(animals) + new.births)      # Number of animals in each cohort
      # Calves (male)
      narw.pop[prj, i, 1] &lt;- sum((narw.indiv[[prj]][i, "cohort", animals] == 0) *
                                   (narw.indiv[[prj]][i, "female", animals] == 0) *
                                   (narw.indiv[[prj]][i, "alive", animals] == 1))      # Juveniles and adults (male)
      narw.pop[prj, i, 2] &lt;- sum((narw.indiv[[prj]][i, "cohort", animals] == 1) * (narw.indiv[[prj]][i, "alive", animals] == 1))
      narw.pop[prj, i, 3] &lt;- sum((narw.indiv[[prj]][i, "cohort", animals] == 3) * (narw.indiv[[prj]][i, "alive", animals] == 1))      # Calves (female)
      narw.pop[prj, i, 4] &lt;- sum((narw.indiv[[prj]][i, "cohort", animals] == 0) *
                                   (narw.indiv[[prj]][i, "female", animals] == 1) *
                                   (narw.indiv[[prj]][i, "alive", animals] == 1))      # Juvenile and reproductive adults (female)
      narw.pop[prj, i, 5] &lt;- sum((narw.indiv[[prj]][i, "cohort", animals] == 2) * (narw.indiv[[prj]][i, "alive", animals] == 1))
      narw.pop[prj, i, 6] &lt;- sum((narw.indiv[[prj]][i, "cohort", animals] == 4) * (narw.indiv[[prj]][i, "alive", animals] == 1))
      narw.pop[prj, i, 7] &lt;- sum((narw.indiv[[prj]][i, "cohort", animals] == 5) * (narw.indiv[[prj]][i, "alive", animals] == 1))
      narw.pop[prj, i, 8] &lt;- sum((narw.indiv[[prj]][i, "cohort", animals] == 6) * (narw.indiv[[prj]][i, "alive", animals] == 1))      # Total population size
      tot.pop[prj, i] &lt;- sum(narw.indiv[[prj]][i, "alive", animals], na.rm = TRUE)     # End years
   # End projections  end.time &lt;- Sys.time()
  run_time &lt;- hms::round_hms(hms::as_hms(difftime(time1 = end.time, time2 = start.time, units = "auto")), 1)  cat("Processing outputs ...")  # narw.out &lt;- purrr::map(.x = 1:n, .f = ~
  #   reshape_array(narw.indiv[[.x]], value, yr, attr, whale) |&gt; 
  #     dplyr::mutate(attr = mat.attribs[attr]) |&gt; 
  #     tidyr::pivot_wider(names_from = attr, values_from = value) |&gt; 
  #     dplyr::mutate(prj = .x) |&gt; 
  #     dplyr::relocate(prj, .before = yr)
  # ) |&gt; do.call(what = rbind) |&gt; 
  #   data.table::data.table()  # narw.out &lt;- narw.out[is.finite(rowSums(narw.out)),]  narw.df &lt;- purrr::map(.x = cohorts$name, .f = ~
    narw.pop[,,.x] |&gt; 
      tibble::as_tibble() |&gt; 
      tibble::rownames_to_column(var = "prj") |&gt; 
      tidyr::pivot_longer(!prj, names_to = "year", values_to = "N") |&gt; 
      dplyr::mutate(year = current.yr + as.numeric(gsub("yr ", "", year))) |&gt; 
      dplyr::mutate(cohort = stringr::str_to_sentence(.x))
  ) |&gt; do.call(what = rbind) |&gt; data.table::data.table()  tot.df &lt;- tibble::as_tibble(tot.pop) |&gt; 
    tibble::rownames_to_column(var = "prj") |&gt; 
    tidyr::pivot_longer(!prj, names_to = "year", values_to = "N") |&gt; 
    dplyr::mutate(year = current.yr + as.numeric(gsub("yr ", "", year))) |&gt; 
    dplyr::mutate(cohort = "North Atlantic right whales") |&gt; data.table::data.table()  # births.df &lt;- purrr::map(.x = 1:n, .f = ~
  #   m &lt;- matrix(rowSums(narw.indiv[[.x]][2:(yrs+1),"birth",], na.rm = TRUE), ncol = 1)
  #   colnames(m) &lt;- .x
  #   m
  # ) |&gt; do.call(what = cbind) |&gt; 
  #   tibble::as_tibble() |&gt; 
  #   tibble::rownames_to_column(var = "year") |&gt; 
  #   dplyr::mutate(year = as.numeric(year)) |&gt; 
  #   tidyr::pivot_longer(!year, names_to = "prj", values_to = "birth") |&gt; 
  #   dplyr::select(prj, year, birth) |&gt; 
  #   dplyr::arrange(prj, year) |&gt; 
  #   data.table::data.table()
  # 
  # deaths.df &lt;- purrr::map(.x = 1:n, .f = ~
  #   m &lt;- matrix(apply(X = narw.indiv[[.x]][2:(yrs+1),"alive",],
  #                     MARGIN = 1,
  #                     FUN = function(x) 
  #     r &lt;- x[!is.na(x)]
  #     r &lt;- sum(r == 0)
  #     r
  #     ), ncol = 1)
  #   colnames(m) &lt;- .x
  #   m
  # ) |&gt; do.call(what = cbind) |&gt;
  #   tibble::as_tibble() |&gt;
  #   tibble::rownames_to_column(var = "year") |&gt;
  #   dplyr::mutate(year = as.numeric(year)) |&gt;
  #   tidyr::pivot_longer(!year, names_to = "prj", values_to = "death") |&gt;
  #   dplyr::select(prj, year, death) |&gt;
  #   dplyr::arrange(prj, year) |&gt;
  #   data.table::data.table()  narw.conf &lt;- narw.df[
    , list(
      mean = mean(N),
      lwr = quantile(N, 0.025, na.rm = TRUE),
      uppr = quantile(N, 0.975, na.rm = TRUE)
    ),
    list(year, cohort)
  ] |&gt;
    dplyr::mutate(cohort = factor(cohort, levels = c(
      "Calves (male)",
      "Calves (female)",
      "Juveniles (male)",
      "Juveniles (female)",
      "Adults (male)",
      "Adults (female, pregnant)",
      "Adults (female, lactating)",
      "Adults (female, resting)"
    )))  tot.conf &lt;- tot.df[
    , list(
      mean = mean(N),
      lwr = quantile(N, 0.025),
      uppr = quantile(N, 0.975)
    ),
    list(year, cohort)
  ] |&gt;
    dplyr::mutate(cohort = factor(cohort, levels = c(
      "Calves (male)",
      "Calves (female)",
      "Juveniles (male)",
      "Juveniles (female)",
      "Adults (male)",
      "Adults (female, pregnant)",
      "Adults (female, lactating)",
      "Adults (female, resting)",
      "North Atlantic right whales"
    )))  p1 &lt;- plot_projection(narw.df, narw.conf)
  p2 &lt;- plot_projection(tot.df, tot.conf)  if(do.plot)
    print(p1)
    print(p2)  # Find 95<!-- % confidence intervals on final population size -->
  cat("Final population size:")
  final.pop &lt;- unname(tot.df[year == current.yr + yrs,  quantile(N, probs = c(0.5, 0.025, 0.975))])
  cat("N = ", round(final.pop[1],0), " (95<!-- % CI: ", round(final.pop[2],0), "–", round(final.pop[3],0), ")\n", sep = "") -->  cat(paste0("Time elapsed: ", run_time))
  cat("")  return(list(
    # dat = narw.out,
    out = list(df = rbind(narw.df, tot.df), 
               ci = rbind(narw.conf, tot.conf),
               plot = list(p1, p2))))</p>
    </div>

    <div id="ref-usage">
    <div class="sourceCode"><pre class="sourceCode r"><code><span><span class="fu">predict_m</span><span class="op">(</span><span class="va">model</span>, cohort <span class="op">=</span> <span class="cn">NULL</span>, <span class="va">values</span>, prediction <span class="op">=</span> <span class="st">"surv"</span><span class="op">)</span></span></code></pre></div>
    </div>


  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top"><h2 data-toc-skip>Contents</h2>
    </nav></div>
</div>


      <footer><div class="copyright">
  <p></p><p>Developed by P. Bouchet, E. Pirotta, J. Hewitt, R. Schick, C. Harris, L. Thomas.</p>
</div>

<div class="pkgdown">
  <p></p><p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

      </footer></div>

  


  

  </body></html>

